var documenterSearchIndex = {"docs":
[{"location":"filtering-data/#Filtering-data","page":"Filtering data","title":"Filtering data","text":"","category":"section"},{"location":"filtering-data/#General-options","page":"Filtering data","title":"General options","text":"","category":"section"},{"location":"filtering-data/#Additional-options-for-data-preprocessed-with-ESMValTool","page":"Filtering data","title":"Additional options for data preprocessed with ESMValTool","text":"","category":"section"},{"location":"filtering-data/#Data-structure","page":"Filtering data","title":"Data structure","text":"","category":"section"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"When the data was preprocessed with ESMValTool, the structure of the directories where the data is stored looks as follows. Uppercase names refer to variables, lowercase names mean that the names can be arbitrary unless stated differently in the comments to the right. ","category":"page"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"├── BASE_DIR # arbitrary (ESMValTool recipe name + _ + YYYYMMDD_HHMMSS)\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)\n│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)\n│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── possibly other output from ESMValTool\n....","category":"page"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"In ESMValTool, BASE_DIR is the name of the recipe plus the date and time using the format YYYYMMDDHHMMSS. ALIAS corresponds to the name (chosen by the user) of the diagnostics defined in the recipe. `VARSTATISTICrefers to the name of the entries among thevariables` section in the ESMValTool recipe. We set these names to the short name of the variable (e.g. 'tas') and the applied statistic (e.g. 'CLIM'),  concatenated by an underscore (e.g, tasCLIM). Any name can be chosen here; but when using VARSTAT, the data can be subset to certain statistics only (see below).","category":"page"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"The structure is basically the same if there is not a seperate subdirectory for each climate  variable, except that the BASE_DIR refers to the directory that immediately contains the  preproc-subdirectory:","category":"page"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"If there is one subdirectory for each climate variable (this is, for instance, the case when one ESMValTool recipe is used for a single variable), the structure of the data is nearly the same. The only difference is that the upper most directory, BASEDIR, has subdirectories which then point to the directory called 'preproc'. The name of each of the subdirectories is assumened to contain _VAR, e.g. (BASEDIR/recipetaslgm or BASEDIR/recipetoslgm). If ESMValTool is used, the name of the subdirectories (subdir1, subdir2) is the name of the recipe concatenated with the timestamp in the format YYYYMMDD_HHMMSS by an underscore.","category":"page"},{"location":"filtering-data/","page":"Filtering data","title":"Filtering data","text":"├── BASE_DIR\n│   └── subdir1  # name must contain \"_VAR_\" where VAR is the short_name of the variable, e.g. _tos_\n│   └── subdir2  # name must contain \"_VAR_\" where VAR is the short_name of the variable, e.g. _tos_\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe\n│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe\n│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── possibly other output from ESMValTool\n....","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Brunner Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020.\nThe logo was created using ChatGPT from OpenAI.","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In the following, we explain how to load data and how to compute model weights.","category":"page"},{"location":"getting-started/#How-to-load-data","page":"Getting started","title":"How to load data","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The data to be loaded is specified in yaml config files. There are two  possibilities how to organize these config files: either we use one or more  ESMValTool recipes that we had used to preprocess the data or we write a new  yaml file, independently of the ESMValTool recipes.","category":"page"},{"location":"getting-started/#Configuration-with-ESMValTool-recipes","page":"Getting started","title":"Configuration with ESMValTool recipes","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"We use the completely spelled out versions of the recipes that ESMValTool returns (RECIPENAME_filled.yml, stored in run-directory).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"import ModelWeights as mw\n\n# set path_data to directory where your preprocessed data is stored\npath_data = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/LGM\";\n# set path_recipes: directory where the ESMValTool recipes are stored \npath_recipes = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/configs-ModelWeights/esmvaltool-recipes/lgm-cmip5-cmip6\";\n\nlgm_data = mw.loadDataFromESMValToolRecipes(\n    path_data, path_recipes;\n    dir_per_var = true, # default: true\n    is_model_data = true, # default: true\n    subset = nothing, # default: nothing\n    preview = false # default: false; if true meta data for data to be loaded is returned\n);","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The loaded data is a Dictionary mapping from an identifier of the form 'variable_diagnostic_alias' (e.g., tas_CLIM_lgm) to a YAXArray. Additional metadata that was added by us is part of the YAXArrays .properties dictionary. All such fields start with an underscore, e.g. '_id', '_paths', '_statistic'.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Not all information in the ESMValTool recipes is required to specify the data to be loaded here. For a minimal example of the required structure, see this example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- TODO: explain dir_per_var argument -->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"How the loaded data can be constrained by the subset argument of the function loadDataFromESMValToolRecipes is described further below. ","category":"page"},{"location":"getting-started/#Configuration-with-seperate-yaml-file","page":"Getting started","title":"Configuration with seperate yaml file","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For an example of a single yaml configuration file see this example.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Keys expected in the config-yaml file:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"path_data: base path to where the preprocessed data is stored. This path will be concatenated with the directories specified for each dataset. It can ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"be omitted if inside datasets (see below), base_dir refers to the entire absolute path.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"datasets: list of each dataset to be loaded. Each dataset is specified by a dictionary with the following keys:\nbase_dir::String: relative path to the data with respect to the path given in path_data. If path_data is not specified in the config file, path_data for this dataset is assumed to refer to an absolute path instead.\nexp::String: e.g., \"historical\"\nvariables::Vector{String}: e.g., [\"tos\", \"tas\"]\nstatistics::Vector{String}: may be empty for fixed variables for which no statistics are computed. In that case, statistics is set to [\"none\"] and a warning is thrown unless for known fixed variables (for now just [orog]).\nThe following keys are optional:\nsubdirs: vector of strings; only subdirectories that contain any of the given strings in their name will be considered.\ntimeranges:\naliases:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"datasets: [\n{\n    base_dir: \"LGM\", \n    exp: \"lgm\", \n    variables: [\"tas\", \"tos\"], \n    statistics: [\"CLIM\"], \n    subdirs: [\"20241114\"]\n},\n{\n    base_dir: \"historical\", # required String\n    exp: \"historical\", # required String\n    variables: [\"tas\", \"tos\"], # required Vector\n    statistics: [\"CLIM\"], # required Vector\n    timeranges: [\"full\"], # optional Vector\n    subdirs: [\"20241121\", \"20241118\"] # optional Vector\n}\n]","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"timerange_to_alias: mapping from timerange to alias.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"timerange_to_alias:\n\"1850-1900\": \"historical0\"\n\"1951-1980\": \"historical1\"","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For each given dataset the respective data is loaded from the base_dir at path_data. The keys base_dir, exp, variables and statistics are required to  specify the data to be loaded.  timeranges and subdirs are optional and work in the same way as when given as field of the optional argument subset described below.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"As we'll explain next, you can also provide further constraints when loading the data using the function loadDataFromYAML. Note that in this case, the values from the provided function argument (subset::Constraint) to filter the data take precedence over what had been specified in the yaml file. ","category":"page"},{"location":"getting-started/#Optional-parameters-for-filtering-data","page":"Getting started","title":"Optional parameters for filtering data","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For both functions, loadDataFromESMValToolRecipes and loadDataFromYAML, there is a set of optional parameters in order to constrain the loaded data:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"preview: If set to false (default), the data will not be loaded and only the metadata with the information that we added that specifies which data will be loaded is returned.\ndir_per_var: If set to true (default), only subdirectories of the base_path that contain _VARIABLE in their name will be searched. \nis_model_data: is set to true (default) when loading CMIP data, to false when loading observationa/reanalysis data (e.g. ERA5).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"<!-- `subset_shared`: Can be either `nothing` (default), `ModelWeights.MODEL` or `ModelWeights.MEMBER`. If set to `MODEL`, only data from the same models will be loaded. If, for instance, data from lgm and historical experiments shall be loaded, this configuration will ensure that for both, only the same models are loaded, i.e. those for which both experiments were done. While this considers models, not specific simulations, setting subset\\_shared to `MEMBER` would only load models that share the exact same simulations (i.e. the same member\\_id abbreviation, e.g. `r1i1p1f1`). -->","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"subset is an optional parameter of type Constraint or Nothing. A Constraint further constrains the data to be loaded and has the following fields:\nvariables: The short name of the climate variable, e.g. [\"tas\", \"tos\"].\nstatistics: The statistic/diagnostic that was used when preprocessing the data. The names are generally arbitrary, but need to be identical to those you used in the preprocessing; for instance, we refer to the climatological average as \"CLIM\", s.t. an example value for this argument is [\"CLIM\"].\naliases: Like for statistics, the names are arbitrary but must be identical to what you used when preprocessing the data; e.g. [\"historical\", \"historical1\"].\nAn alias should refer to a certain timerange of a certain experiment, e.g. we call the time period from 1951-1980 'historical1'. To load only this data, it thus does not matter whether you set timerange=[\"1951-1980\"] or alias=[\"historical1\"].\ntimeranges: Timeranges to be loaded; especially for historical data, you may preprocess data for different timeranges,  e.g. [\"full\", \"1980-2014\"]. \nprojects:  e.g. [\"CMIP5\", \"CMIP6\"]. All filenames of the data to be loaded must contain at least one of the given strings. If not specified and is_model_data=true, it is set to [\"CMIP\"]. If not specified and is_model_data=false, it is set to [\"ERA5\"], the default observational dataset used.\nmodels: List of models or individual model members, e.g. [\"AWI-CM-1-1-MR\"]. All filenames must contain at least one of the given strings + \"_\". The underscore is important since some models have names that are substrings of other models, e.g. \"CNRM-CM5\" and \"CNRM-CM5-C2\". \nbase_subdirs: If there is one directory for each climate variable (dir_per_var=true), you can use this argument to subset the considered subdirectories: if given, the data will be loaded only from subdirectories of the given base_dir that contain any of the provided values in base_subdirs in their name. That is, it's not necessary to specify full directory names here, parts of it are sufficient.","category":"page"},{"location":"getting-started/#How-to-compute-weights","page":"Getting started","title":"How to compute weights","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For a full example, see scripts/run-climwip-simplified.yml.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Calling mw.computeWeights(dists_indep, dists_perform, config) will compute weights based on the distances for the independence weights and the distances for the performance weights. The config parameter is of type ConfigWeights defined in src/data-utils.jl. It holds information about the contribution of each combination of statistic/diagnostic and climate variable, once for computing independence weights and once for computing performance weights. Further parameters concerning the weighting are specified in the ConfigWeights struct, such as the hyperparameters,  sigma_performance and sigma_independence. ","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The output of the function `computeWeights` is an object of type `Weights` (see `src/data-utils.jl`) which contains the independence and performance weights seperately as well as the overall weights (`wI`, `wP` and `w`), each of which respectively sum up to 1. Further it contains the following data:\n- For all combinations of statistics/diagnostics and climate variables, the distances used for computing performance as well as independence weights (`performance_distances`, `independence_distances`). \n- For every model, the generalized distances for performance (`Di`) and independence (`Sij`), (distances summed across statistics/diagnostics + variables).\n- Model weights on the basis of members, i.e. the weight for every model is distributed evenly across its members, so this gives one weight per member.\n- the configuration in form of the `ConfigWeights` object used to compute the weights.\n\n","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"@raw html <!– weights_variables:: For each of 'performance' and 'independence' one value per climate variable considered. These values represent the weight of how much each climate variable influences the generalized distance of a model, which is computed by taking a weighted average across the distances with respect to different variables. Should sum up to 1.  –> ```","category":"page"},{"location":"examples/climwip/#Climwip-example-from-Brunner-et-al.-(2020)","page":"Climwip example from Brunner et al. (2020)","title":"Climwip example from Brunner et al. (2020)","text":"","category":"section"},{"location":"weights/#Computing-weights","page":"Computing weights","title":"Computing weights","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The weighting method that we use is from Brunner et al. (2020), see References.","category":"page"},{"location":"weights/#Area-weighted-RMSE","page":"Computing weights","title":"Area-weighted RMSE","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"d_i^k = sqrtsum_l w_l (X_l^a (ik) - X_l^a obs)^2","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The variable d_i^k is the area-weighted root mean squared error between the predictions of a model, namely the k-th member of model i, and the observational data (or for independence weights between pairs of models):","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"Variable l iterates over (lon, lat)-positions and w_l are the area weights, which account for the different grid cell areas depending on the latitudes. d_i^k is computed for all individual model members, for each diagnostic and variable (denoted as a, which may, for instance, refer to the climatological average, CLIM, of near-surface air temperature, tas).","category":"page"},{"location":"weights/#Generalized-distances","page":"Computing weights","title":"Generalized distances","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The weights are computed for each model (i.e. not on the level of model members). They are based on the generalized distances.  To compute the generalized distances and subsequently the actual weights per model (w_i), the different members of each model are first summarized to yield one distance value per model. This is defined as the average distance, d^prime_i over all distances of K_i members of model i (for a specific combination of diagnostic and variable a): ","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"d_i ^prime a = fracsum_k^K_i d_i^kK_i","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The generalized distances are then defined as follows:","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"D_i = sum_a w_a cdot fracd_i^prime atextrmMEDIAN(d^a)","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"Here, the sum iterates over the combination of diagnostics and variables (a) and w_a refers to the weights for each combination of diagnostic and variable. So, D_i is the weighted average over all model distances which are further normalized by the median computed across all model members, seperately for each combination of diagnostic and variable. So, d^a in the denominator refers to the distances of all model members for the combination of diagnostic and variable, a.  Note: it doesn't matter if you first average the distances (d^prime a_i), to get one value per model and normalize then or normalize first and average then (given that the normalization is in both cases the median across all models and members).","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"That is, we get a generalized distance value D_i for every model i, respectively values S_ij for every pair of models ij.","category":"page"},{"location":"weights/#Computation-of-overall-weight-for-model-i","page":"Computing weights","title":"Computation of overall weight for model i","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The generalized distances between models and observations, respectively between model pairs are then combined as follows to yield one weight value for each model i (w_i's are normalized by sum_i w_i):","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w_i = frace^-(fracD_isigma_D)^21 + sum_j ne i e^-left( fracS_ijsigma_S right)^2","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"The parameters, sigma_D and sigma_S, are free parameters that Brunner et al. estimated using perfect model tests.","category":"page"},{"location":"weights/#Computation-of-performance/independence-weights-only","page":"Computing weights","title":"Computation of performance/independence weights only","text":"","category":"section"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"When computing only performance weights, we assume that all models are equally dependent:","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w^P_i = frace^-(fracD_isigma_D)^2N","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"When computing only independence weights, we assume that all models perform equally well.","category":"page"},{"location":"weights/","page":"Computing weights","title":"Computing weights","text":"w^I_i = frac11 + sum_j ne i e^-left( fracS_ijsigma_S right)^2","category":"page"},{"location":"loading-data/#Loading-data","page":"Loading data","title":"Loading data","text":"","category":"section"},{"location":"loading-data/#Loading-data-from-directories","page":"Loading data","title":"Loading data from directories","text":"","category":"section"},{"location":"loading-data/#Loading-data-preprocessed-with-ESMValTool","page":"Loading data","title":"Loading data preprocessed with ESMValTool","text":"","category":"section"},{"location":"loading-data/#Based-on-recipes","page":"Loading data","title":"Based on recipes","text":"","category":"section"},{"location":"loading-data/#Based-on-config-files","page":"Loading data","title":"Based on config files","text":"","category":"section"},{"location":"loading-data/","page":"Loading data","title":"Loading data","text":"If the data is loaded from ESMValToolRecipes, you may have one centralized directory, where you store the all recipe files, namely those output by ESMValTool (inside the run folder, then 'RECIPENAMEfilled.yml'). Note that not everything in the recipes is actually needed for loading the data. For a minimal example with the unnecessary sections removed, see this example","category":"page"},{"location":"loading-data/","page":"Loading data","title":"Loading data","text":"Further, to load the data, we need one or more yaml configuration files. From these, we retrieve which combination of variables, statistics, aliases, experiments and timeranges will be considered.","category":"page"},{"location":"requirements/#Requirements","page":"Requirements","title":"Requirements","text":"","category":"section"},{"location":"requirements/","page":"Requirements","title":"Requirements","text":"We assume that you have your preprocessed data ready, so that the data from the different models can be combined, meaning that all models must for instance be defined on the same grid. We do the preprocessing of the data with ESMValTool.   <!– A set of recipes to download and preprocess some data can be found in our repository ESMDataPrep. –>","category":"page"},{"location":"examples/lgm/#Weights-for-models-of-lgm-experiment","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"","category":"section"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"First, we want to load all CMIP5 and CMIP6 model data for the lgm-experiment.","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"# points to directory where preprocessed data is stored\npath_data = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/LGM\";\n# point to directory where config files are stored\npath_recipes = \"/albedo/home/brgrus001/SimilarityWeights/configs/lgm-cmip5-cmip6\";\n\nlgm_data = mw.loadDataFromESMValToolConfigs(\n    path_data, path_recipes;\n    dir_per_var = true, # default: true\n    is_model_data = true, # default: true \n    only_shared_models = true, # default: false\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"lgm\"],\n        projects = [\"CMIP5\", \"CMIP6\"],\n        models = Vector{String}(),\n        subdirs = [\"20241114\"]\n    ),\n    preview = false # default value is false\n);\nmodel_members_lgm = Array(dims(first(values(lgm_data)), :member))","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"Then, we load data from the same models for the historical experiment:","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"base_path = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/historical/\";\nconfig_path = \"/albedo/home/brgrus001/SimilarityWeights/configs/historical\";\nhistorical_data = mw.loadDataFromESMValToolConfigs(\n    base_path, config_path;\n    only_shared_models = true,\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"historical\"],\n        timeranges = [\"full\"],\n        models = model_members_lgm,\n        subdirs = [\"20241121\", \"20241118\"]\n    )\n);\n````\n\nThis is the resulting data:","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"julia","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"\nWe could also have used a single yaml configuration file independent of the ESMValTool recipes and load the data all together one:\n\n","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"julia","category":"page"},{"location":"examples/lgm/#Load-model-data-for-experiment-lgm-and-historical-in-one-run-from-new-config-file","page":"Weights for models of lgm experiment","title":"Load model data for experiment lgm and historical in one run from new config file","text":"","category":"section"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"pathconfig = \"/albedo/work/projects/pforclima/preprocdataesmvaltool/configs-SimilarityWeights/example-lgm-historical.yml\";","category":"page"},{"location":"examples/lgm/","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"modeldata = mw.loadDataFromYAML(     pathconfig;     dirpervar = true, # default: true     ismodeldata = true, # default: true     onlysharedmodels = true, # default: false     preview = false ); ```","category":"page"},{"location":"examples/lgm/#TODO:-show-that-we-get-the-same-outfit-different-approaches!","page":"Weights for models of lgm experiment","title":"TODO: show that we get the same outfit different approaches!","text":"","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is twofold: on the one hand, we built it to handle preprocessed Earth System data easily within Julia and, on the other hand, to compute weights for different sets of Earth System Models following the approach from Brunner et al (2020) and  adding the possibility to use and combine different performance metrics.","category":"page"},{"location":"#Data-Representation","page":"Home","title":"Data Representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The basic representation of data is in form of a dictionary that simply maps from ids  (Strings) to the data itself stored as YAXArrays. We name this type alias a DataMap. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The metadata of each dataset (datamapidproperties) contains the  metadata loaded from the original files as well as additional information if it is provided in the optional argument meta_data.","category":"page"},{"location":"#Weights","page":"Home","title":"Weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<!– julia import ModelWeights as mw weights = mwcomputeWeights(model_data_historical obs_data config_weights)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Weights object has several fields that each store a DimensionalData.DimArray. Some of them refer to normalized weights, others refer  to the distances on the basis of which the weights were computed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"performance_distances and independence_distances contain the distances","category":"page"},{"location":"","page":"Home","title":"Home","text":"between models and data (performance) or between models and models (independence)  for every combination of variable and diagnostic/statistic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Di and Sij are the generalized distances, i.e. weighted average of all","category":"page"},{"location":"","page":"Home","title":"Home","text":"distances across variables and diagnostic. So, D_i is a vector with size  1xn where n is the number of models (not on level of members!) and S_ij is  a matrix of size n x n. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"wP and wI respectively store the normalized performance/independence weights, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"both have size 1xn (n: number of models).","category":"page"},{"location":"","page":"Home","title":"Home","text":"w is the overall weight vector of length n. –>","category":"page"},{"location":"#Application-of-weights","page":"Home","title":"Application of weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add example of how weights are applied to data","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"#ModelWeights.Data.alignPhysics-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.Data.alignPhysics","text":"alignPhysics(data::YAXArray, members::Vector{String})\n\nReturn new YAXArray with the models retained from data that share the same physics as  the respective model's members in members. All other models that are in data but for which no member is specified in members are  also retained.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.anomalies-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.anomalies","text":"anomalies(orig_data::YAXArray, ref_data::YAXArray)\n\nCompute difference of orig_data and ref_data.  \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.apply-Union{Tuple{T}, Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Function, Vararg{Any}}} where T<:Union{String, Symbol}","page":"Home","title":"ModelWeights.Data.apply","text":"apply(\n    dm::DataMap,\n    fn::Function,\n    args...; \n    ids::AbstractVector{T} = Vector{String}(),\n    ids_new::AbstractVector{T} = Vector{String}(),\n    kwargs...\n)\n\nApply fn with positional arguments args and keyword arguments  kwargs and return result as a new DataMap where keys are ids_new if provided, otherwise same keys as in dm are used.\n\nArguments:\n\ndm::DataMap: data.\nfn::Function: function to be applied.\nargs...: positional arguments for fn.\nids::AbstractVector{T}=Vector{String}(): keys for data on which fn is applied; if empty all keys of dm are used.\nids_new::AbstractVector{T}=Vector{String}(): keys used in new datamap; if empty ids are used instead.\nkwargs...: keyword arguments for fn.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.approxAreaWeights-Tuple{AbstractVector{<:Number}}","page":"Home","title":"ModelWeights.Data.approxAreaWeights","text":"approxAreaWeights(latitudes::Vector{<:Number})\n\nCreate a YAXArray with the cosine of latitudes which approximates the cell  area on the respective latitude.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.areaWeightedRMSE-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"Home","title":"ModelWeights.Data.areaWeightedRMSE","text":"areaWeightedRMSE(m1::AbstractArray, m2::AbstractArray, mask::AbstractArray)\n\nCompute the area weighted (approximated by cosine of latitudes in radians) root mean squared  error between m1 and m2. \n\nArguments:\n\nm1: must have dimensions 'lon', 'lat' as first dimensions.\nm2: must have dimensions 'lon', 'lat' as first dimensions.\nmask: indicates missing values (1 refers to missing, 0 to non-missing).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.checkConstraint-Tuple{Union{Nothing, Dict}}","page":"Home","title":"ModelWeights.Data.checkConstraint","text":"checkConstraint(constraint::Union{Dict, Nothing})\n\nThrow error if entries (except for level_shared) do not map to a vector of Strings.\n\nUsed to provide specific error messages of values that were not specified correctly.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.combineAll-Tuple{Vararg{Vector{String}}}","page":"Home","title":"ModelWeights.Data.combineAll","text":"combineAll(v::Vararg{Vector{String}}; sep::String=\"_\")\n\nGenerate vector with all possible combinations of strings, each of which is a concatenation  of elements from each input vector in the given order, concatenated by sep (default: _).\n\nArguments\n\nv::Vararg{Vector{String}}: A variable number of input vectors.\nsep::String: seperator\n\nExample\n\njulia> ModelWeights.Data.combineAll([\"tos\", \"tas\"], [\"CLIM\"])\n2-element Vector{String}:\n \"tos_CLIM\"\n \"tas_CLIM\"\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.combineModelsFromMultipleFiles-Union{Tuple{AbstractVector{<:AbstractArray}}, Tuple{T}} where T","page":"Home","title":"ModelWeights.Data.combineModelsFromMultipleFiles","text":"combineModelsFromMultipleFiles(\n    data::Vector{AbstractArray}; \n    model_names::Vector{String} = Vector{String}(),\n    meta::Union{Dict{String, T}, Nothing} = nothing,\n    dtype::String = \"undef\",\n    new_dim::Symbol = :model,\n    sorted::Bool = true\n\n) where T <: Any\n\nCombine data from different files into a single YAXArray.  The meta data of the returned YAXArray is a combination of all values from all datasets  using vectors with missing values for datasets that didn't have the respective metadata  entry in their metadata, further combined with the properties in meta if provided.\n\nAll elements in data must share all dimensions except for time (if present). For timeseries data, the time dimension may cover different ranges. In that case the  maximal timeseries is used and filled with NaN for missing values.  \n\nThe combined YAXArray has the additional dimension new_dim (default: :model) with names as values. If names is not provided, default values 'model1', 'model2, etc. are used  instead.\n\nIf sorted is true, model dimension of returned data is sorted alphabetically and the  vector entries in the metadata dictionary of the returned array are also sorted accordingly.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.constrainMetaData!-Tuple{Vector{ModelWeights.Data.MetaData}, Dict}","page":"Home","title":"ModelWeights.Data.constrainMetaData!","text":"constrainMetaData!(meta_attributes::Vector{MetaData}, constraint::Dict)\n\nSubset entries in meta_attributes so that only those with properties specified  in constraint remain.\n\nArguments\n\nconstraint::Dict: Mapping to vector specifiying the properties of which at least one \n\nmust be present for an id to be retained.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{String}, String}} where T","page":"Home","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    path_data_dir::String, \n    id::String;\n    meta_data::Dict{String, T} = Dict{String, Any}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"undef\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entry id with the data (model and/or obs depending on dtype) from  all .nc files in paths and all .nc files in all directories in paths, possibly  constraint by constraint.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{String}, Vector{String}}} where T","page":"Home","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    paths_data_dirs::Vector{String}, \n    data_ids::Vector{String};\n    meta_data::Vector{Dict{String, T}} = Vector{Dict{String, Any}}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"undef\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entries data_ids with the data (model and/or obs depending on dtype)  from all .nc files in all directories in paths_data_dirs, possibly constraint by constraint.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{Vector{String}}, Vector{String}}} where T","page":"Home","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    paths_data_dirs::Vector{String}, \n    data_ids::Vector{String};\n    meta_data::Vector{Dict{String, T}} = Vector{Dict{String, Any}}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"undef\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entries data_ids with the data (model and/or obs depending on dtype)  from all .nc files in all directories in paths_dirs, possibly constraint by constraint.\n\nFor every loaded dataset (entry in built DataMap), files are loaded from several directories; each entry in paths_data_dirs points the the vector of data directories from where data  is loaded for that dataset.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.dict2YAX-Tuple{Dict{String, <:Number}}","page":"Home","title":"ModelWeights.Data.dict2YAX","text":"dict2YAX(data::Dict{String, <:Number})\n\nConvert dictionary data into a YAXArray with new dimension dim_name  (default is :diagnostic) whose lookup names are the keys of data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.dimNames-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.dimNames","text":"dimNames(data::YAXArray)\n\nReturn the names of the dimensions of data as vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.distancesData-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Home","title":"ModelWeights.Data.distancesData","text":"distancesData(model_data::DataMap, obs_data::DataMap, diagnostics::Vector{String})\n\nCompute RMSEs between models and observations for diagnostics.\n\nArguments:\n\ndiagnostics::Vector{String}: keys for which values must be provided in model_data and \n\nobs_data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.distancesData-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.distancesData","text":"distancesData(models::YAXArray, observations::YAXArray)\n\nCompute the distance as the area-weighted RMSE between model predictions and observations.\n\nIf several observational datasets are present, the average across all is taken.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.distancesModels-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Home","title":"ModelWeights.Data.distancesModels","text":"distancesModels(model_data::DataMap, diagnostics::Vector{String})\n\nCompute the model-model distances for model_data at every diagnostic in diagnostics and  return a vector of YAXArrays.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.distancesModels-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.distancesModels","text":"distancesModels(data::YAXArray)\n\nCompute the area weighted RMSE between model predictions for each pair of models.\n\nArguments:\n\ndata::YAXArray: first two dimensions must be 'lon', 'lat', third 'model' or 'member'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.filterPathsSharedModels-Tuple{Vector{String}, Vector{String}, Union{String, Symbol}}","page":"Home","title":"ModelWeights.Data.filterPathsSharedModels","text":"filterPathsSharedModels(\n    paths::Vector{String}, \n    shared_models::Vector{String}, \n    fn_format::Union{Symbol, String}\n)\n\nEvery vector of paths in all_paths is filtered s.t. it only contains models or model  members given in shared_models.\n\nArguments:\n\npaths: contains paths to data files\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.filterPathsSharedModels-Tuple{Vector{Vector{String}}, ModelWeights.Data.Level, Union{String, Symbol}}","page":"Home","title":"ModelWeights.Data.filterPathsSharedModels","text":"filterPathsSharedModels(\n    all_paths::Vector{Vector{String}}, \n    level_shared::Level, \n    fn_format::Union{Symbol, String}\n)\n\nArguments:\n\nall_paths: every entry refers to the paths to data files for the respective dataset\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.generalizedDistances-Tuple{Vector{<:YAXArrays.Cubes.YAXArray}, Vector{String}, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.generalizedDistances","text":"generalizedDistances(distances_all::Vector{YAXArray}, weights::YAXArray)\n\nArguments:\n\ndistances_all::Vector{YAXArray}: each entry refers to the distances of one diagnostic, \n\neach must have dimension 'model', 'member' or 'member1' and 'member2' (must be identical for  every entry!).\n\nweights::YAXArray\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.generalizedDistances-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.generalizedDistances","text":"generalizedDistances(distances_all::YAXArray, weights::YAXArray)\n\nFor every diagnostic in distances_all, compute the weighted sum of all diagnostics.\n\nArguments:\n\ndistances_all::YAXArray: must have dimension :diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.getAtModel-Tuple{YAXArrays.Cubes.YAXArray, Symbol, String}","page":"Home","title":"ModelWeights.Data.getAtModel","text":"getAtModel(data::YAXArray, dimension::Symbol, model::String)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.getByIdxModel-Tuple{YAXArrays.Cubes.YAXArray, Symbol, Vector}","page":"Home","title":"ModelWeights.Data.getByIdxModel","text":"getByIdxModel(data::YAXArray, dimension::Symbol, indices::Vector)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.getCMIPModelsKey-Tuple{Dict}","page":"Home","title":"ModelWeights.Data.getCMIPModelsKey","text":"getCMIPModelsKey(meta::Dict)\n\nReturn the respective key to retrieve model names in CMIP6 ('sourceid') and  CMIP5 ('modelid') data.\n\nIf both keys are present, 'source_id' used in CMIP6 models is returned, if none  is present, throw ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.globalMeans-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.globalMeans","text":"globalMeans(data::YAXArray)\n\nReturn a YAXArray with area-weighted global means for each model in data. \n\nMissing data is accounted for in the area-weights. \n\nArguments:\n\ndata::YAXArray: must have dimensions 'lon' and 'lat'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.indexModel-Union{Tuple{N}, Tuple{YAXArrays.Cubes.YAXArray, NTuple{N, Symbol}, Vector{Int64}}} where N","page":"Home","title":"ModelWeights.Data.indexModel","text":"indexModel(data::YAXArray, model_dims::Tuple{Symbol}, indices::Vector{Int})\n\nReturn data at model dimensions model_dims at indices.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.indicesTimeseries-Tuple{Vector{Dates.DateTime}, Dict}","page":"Home","title":"ModelWeights.Data.indicesTimeseries","text":"indicesTimeseries(times::Vector, constraint_ts::Dict)\n\nGet indices of times that are exactly aligned with start_y and end_y given in constraint_ts. If no values are given, return indices for entire vector times.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.individuatePath-Tuple{String}","page":"Home","title":"ModelWeights.Data.individuatePath","text":"individuatePath(target::String)\n\nIf file at target path exists, concatenate target with current timestep, otherwise  simply return target.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.interpolatedWeightedQuantiles-Tuple{Vector{<:Number}, Vector}","page":"Home","title":"ModelWeights.Data.interpolatedWeightedQuantiles","text":"interpolatedWeightedQuantiles(\n    quantiles::Vector{<:Number}, vals::Vector; weights=nothing\n)\n\nThis implementation follows the one used by Brunner et al.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.joinDicts-Tuple{Vararg{Dict}}","page":"Home","title":"ModelWeights.Data.joinDicts","text":"joinDicts(v::Dict...; warn_msg::String=\"\")\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.kelvinToCelsius!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.Data.kelvinToCelsius!","text":"kelvinToCelsius!(datamap::DataMap)\n\nModify entries of datamap s.t. all data is given in Degree Celsius (instead) of Kelvin.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.kelvinToCelsius-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.kelvinToCelsius","text":"kelvinToCelsius(data::AbstractArray)\n\nReturn a copy of data with values given in Kelvin covnerted into Degree Celsius.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.loadDataFromESMValToolRecipes-Tuple{String, String}","page":"Home","title":"ModelWeights.Data.loadDataFromESMValToolRecipes","text":"loadDataFromESMValToolRecipes(\n    path_data::String,\n    path_recipes::String;\n    dir_per_var::Bool = true,\n    constraint::Union{Dict, Nothing} = nothing,\n    preview::Bool = false,\n    sorted::Bool = true\n)\n\nLoad the data from the ESMValTool recipes at path_recipes or, if preview is true, load meta data only.\n\nArguments:\n\npath_data: top level directory were data is stored.\npath_recipes: directory were ESMValTool recipes are stored; these must be the versions \n\nin the run folder generated by ESMValTool named  RECIPENAME_filled.yml.\n\ndir_per_var: set to true (default) if there is a subdirectory in path_data for every \n\nclimate variable to be loaded.\n\nconstraint: TODO!\npreview: set to true if only meta data should be loaded (default: false).\nsorted: if true (default), the data is sorted alphabetically wrt model names.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.loadDataFromYAML-Tuple{Dict}","page":"Home","title":"ModelWeights.Data.loadDataFromYAML","text":"loadDataFromYAML(\n    content::Dict;\n    constraint::Union{Dict, Nothing} = nothing,\n    preview::Bool = false,\n    sorted::Bool = true,\n    dtype::String = \"undef\"\n)\n\nReturn a DataMap-instance that contains the data specified in content, potentially  constraint by values in constraint.\n\nArguments:\n\npreview::Bool: if true (default: false), return metadata and corresponding paths without \n\nactually loading any data.\n\nsorted::Bool: if true (default), model dimension is sorted alphabetically.\ndtype::String: if set to \"cmip\", model dimension of returned data have model names as values.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.loadDataMapCore-Tuple{Vector{Vector{String}}, Vector{String}, Vector{<:Dict}}","page":"Home","title":"ModelWeights.Data.loadDataMapCore","text":"loadDataMapCore(\n    all_paths::Vector{Vector{String}},\n    ids::Vector{String},\n    constraints::Vector{Dict};\n    dtype::String = \"undef\",\n    filename_format::Union{Symbol, String} = :cmip,\n    sorted::Bool = true,\n    preview::Bool = false,\n    meta_data::Union{Vector{Dict{String, T}}, Nothing} = nothing\n) where T <: Any\n\nLoad a DataMap instance with keys ids that map to data at all_paths, where every  subvector refers the the paths of the data of a single dataset. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.loadModelsFromCSV-Tuple{String, String}","page":"Home","title":"ModelWeights.Data.loadModelsFromCSV","text":"loadModelsFromCSV(\n    path::String, col_models::String; col_variants::Union{String,Nothing}=nothing\n)\n\nReturn a vector with models retrieved from csv file at path. If col_variants is provided,  returned models are on level of model members (MODEL#variant, e.g. AWI-ESM#r1i1p1f1).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.loadPreprocData-Union{Tuple{T}, Tuple{Vector{String}, Union{String, Symbol}}} where T","page":"Home","title":"ModelWeights.Data.loadPreprocData","text":"loadPreprocData(\n    paths::Vector{String},\n    filename_format::Union{Symbol, String};\n    sorted::Bool = true, \n    dtype::String = \"undef\",\n    names::Vector{String} = Vector{String}(),\n    meta_info::Union{Dict{String, T}, Nothing} = nothing,\n    constraint_ts::Union{Dict, Nothing} = nothing\n) where T <: Any\n\nReturn data loaded from paths as single YAXArray. \n\nEach path points to a different model, i.e. the data for one dataset is loaded from multiple  files and all datasets in paths must share the same dimensions. Which variable is loaded  is inferred from the filenames (from paths), or if meta_info has key 'variable', the  respective value is used.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.makeAreaWeightMatrix-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Home","title":"ModelWeights.Data.makeAreaWeightMatrix","text":"makeAreaWeightMatrix\n\nArguments:\n\nmask: first two dimensions must refer to lon, lat\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.memberIDFromFilenameMeta-Tuple{ModelWeights.Data.FilenameMeta, String}","page":"Home","title":"ModelWeights.Data.memberIDFromFilenameMeta","text":"memberIDFromFilenameMeta(fn_meta::FilenameMeta)\n\nReturn a string of the form modelname#memberID[_grid] that identifies the corresponding model member.\n\nFor CMIP6 models the abbreviation of the grid is added to the model name.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.memberIDsFromPaths-Tuple{Vector{String}}","page":"Home","title":"ModelWeights.Data.memberIDsFromPaths","text":"memberIDsFromPaths(all_paths::Vector{String})\n\nFor every path in all_paths return a string of the form modelname#memberID[grid] that identifies the corresponding model member. Filenames must follow the CMIP-standard (projnamemipexpidvariable[_grid].nc).\n\nFor CMIP6 models the abbreviation of the grid is added to the model name.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.mergeMetaDataFromMultipleFiles-Tuple{AbstractVector{<:AbstractArray}}","page":"Home","title":"ModelWeights.Data.mergeMetaDataFromMultipleFiles","text":"mergeMetaDataFromMultipleFiles(data::Vector{<:YAXArray})\n\nCombine arrays in data into a single YAXArray with meta combined from all datasets into  lists, with missing if key wasnt in a dataset.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.metaDataChecksCMIP-Tuple{CommonDataModel.Attributes, String}","page":"Home","title":"ModelWeights.Data.metaDataChecksCMIP","text":"metaDataChecksCMIP(meta::Dict, path::String)\n\nCheck model names as retrieved from the metadata for potential inconsistencies wrt filename.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.metaDataFromESMValToolRecipes-Tuple{String}","page":"Home","title":"ModelWeights.Data.metaDataFromESMValToolRecipes","text":"metaDataFromESMValToolRecipes(\n    base_path_configs::String; constraint::Union{Dict, Nothing} = nothing\n)\n\nRead variable, statistic, experiment and timerange/alias values from ESMValTool recipes  stored at base_path_configs into a vector of Dictionaries storing the respective readoff  values.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.metaDataFromYAML-Tuple{Dict}","page":"Home","title":"ModelWeights.Data.metaDataFromYAML","text":"metaDataFromYAML(content::Dict)\n\nReturn metadata of data specified in content possibly constrained by values in arg_constraint.\n\nFor constraints that are specified in content as well as in the arg_constraint argument,  the values of the latter have precedence over the former. The constraints given in the argument arg_constraint are applied to EVERY dataset specified in the config  file.\n\nArguments:\n\ncontent: content of config yaml file specifying meta attributes and paths of data\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.modelDim-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.modelDim","text":"modelDim(data::YAXArray)\n\nReturn the model dimension of data which must either be :model or :member.\n\nIf none is present, throw ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.modelDims-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.modelDims","text":"modelDims(data::YAXArray)\n\nReturn vector of dimensions of data that contain either 'model' or 'member'.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.normalizeDict-Tuple{Dict{String, <:Number}}","page":"Home","title":"ModelWeights.Data.normalizeDict","text":"normalizeDict(data::Dict{String, <:Number})\n\nNormalize values for every entry in data such that they sum up to 1. If remove_zero is true (default), the returned dictionary does not contain entries for which values were 0.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.parseFilename-Tuple{String, String}","page":"Home","title":"ModelWeights.Data.parseFilename","text":"parseFilename(filename::String, format::String)\n\nRetrieve information from filename and returns it as an object of type FilenameMeta.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.putAtModel!-Tuple{YAXArrays.Cubes.YAXArray, Symbol, String, Any}","page":"Home","title":"ModelWeights.Data.putAtModel!","text":"putAtModel!(data::YAXArray, dimension::Symbol, model::String, input)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.readDataFromDisk-Tuple{String}","page":"Home","title":"ModelWeights.Data.readDataFromDisk","text":"readDataFromDisk(target_path::String; variable::String=\"\")\n\nLoad data from target_path. If target_path ends with '.jld2', variable  must be specified, otherwise  data is assumed to be binary.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.resolvePathsFromMetaData-Tuple{ModelWeights.Data.MetaData, String, Bool}","page":"Home","title":"ModelWeights.Data.resolvePathsFromMetaData","text":"resolvePathsFromMetaData( \n    meta::MetaData,\n    base_path::String,\n    dir_per_var::Bool;\n    constraint::Union{Dict, Nothing} = nothing\n)\n\nReturn paths to data files for data specified in meta, possibly constraint by values in  constraint. The paths were the data is stored is expected to follow the following  structure (corresponding to the output from ESMValTool used for preprocessing the data):\n\nbase_path is the top-level directory. If dir_per_var is true, base_path is assumed to  have a (or several) subdirectory for each climate variable with VAR as part of the  subdirectory's name (e.g. _tas, cmip5tas, etc.). These subdirectories may be constraint by  containing at least one of the values in constraint[\"base_subdirs\"]. \n\nLet BASE refer to base_path, or respectively, to the subdirectories for the climate  variables. Then the following structure is: BASE/preproc/meta.alias/meta.subdir.  In ESMValTool, meta.alias corresponds to the (self-chosen) name under the section  'diagnostics' and meta.subdir to the (self-chosen) name under the section 'variables'.\n\nThe returned paths are the paths to all files within this directory, possibly constraint by  the filenames containig at least one string in constraint[\"projects\"] and respectively  at least one string in constraint[\"models\"]. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.setDim-Tuple{YAXArrays.Cubes.YAXArray, Union{String, Symbol}, Union{Nothing, String, Symbol}, Union{Nothing, Vector{String}}}","page":"Home","title":"ModelWeights.Data.setDim","text":"setDim(\n    data::YAXArray, \n    dim::Union{String, Symbol},\n    dim_name::Union{Nothing, String, Symbol},\n    dim_vals::Union{Nothing, Vector{String}}\n)\n\nArguments:\n\ndata::YAXArray:\ndim::Union{String, Symbol}: Name of the dimension to be changed.\ndim_name::Union{Nothing, String, Symbol}: New dimension name.\ndim_vals::Union{Nothing, Vector{String}}:  New dimension values.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.setLookupsFromMemberToModel-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.Data.setLookupsFromMemberToModel","text":"setLookupsFromMemberToModel(data::YAXArray, dim_names::Vector{String})\n\nChange the lookup values for the dimension 'member' to refer to the models, i.e. they are not unique anymore. This is done in preparation to group the data by the different models.\n\nArguments:\n\ndata::YAXArray: has at least dimensions in dim_names.\ndim_names::Vector{String}: names of dimensions to be changed, e.g. 'member', \n\n'member1' (would be changed to 'model', 'model1').\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.sharedLevelMembers-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.Data.sharedLevelMembers","text":"sharedLevelMembers(data::DataMap)\n\nReturn vector of model members that are shared across all entries in data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.sharedLevelModels-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.Data.sharedLevelModels","text":"sharedLevelModels(data::DataMap)\n\nReturn vector of models (on level of models, not members) that are shared across all entries in data.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.sharedModels-Tuple{Vector{Vector{String}}, ModelWeights.Data.Level, Union{String, Symbol}}","page":"Home","title":"ModelWeights.Data.sharedModels","text":"sharedModels(\n    all_paths::Vector{Vector{String}},\n    level_shared::Level,\n    fn_format::Union{Symbol, String}\n)\n\nArguments:\n\nall_paths: every entry refers to the paths to data files for the respective dataset\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.subsetMeta!-Tuple{Dict, Vector{<:Int64}}","page":"Home","title":"ModelWeights.Data.subsetMeta!","text":"subsetMeta(meta::Dict, indices::Vector{<:Int}; simplify::Bool = false)\n\nIf simplify is true, use single value when all remaining elements in a vector in meta are  identical, otherwise just keep vector.\n\nArguments:\n\nmeta:\nindices: indices to remain in vectors mapped to in meta. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.subsetMeta-Tuple{Dict, Vector{<:Int64}}","page":"Home","title":"ModelWeights.Data.subsetMeta","text":"subsetMeta(meta::Dict, indices::Vector{<:Int}; simplify::Bool = false)\n\nIf simplify is true, use single value when all remaining elements in a vector in meta are  identical, otherwise just keep vector.\n\nArguments:\n\nmeta:\nindices: indices to remain in vectors mapped to in meta. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.subsetModelData","page":"Home","title":"ModelWeights.Data.subsetModelData","text":"subsetModelData(datamap::DataMap, level::Level=MEMBER_LEVEL)\n\nFor those datasets in datamap that specify data on the level level (i.e. have dimension  :member or :model), return a new DataMap with subset of data s.t. the new datasets all have  the same models (MODELLEVEL) or members (MEMBERLEVEL).\n\nIf no models are shared across datasets, return the input datamap.\n\n\n\n\n\n","category":"function"},{"location":"#ModelWeights.Data.subsetModelData-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.Data.subsetModelData","text":"subsetModelData(data::YAXArray, shared_models::Vector{String})\n\nReturn subset of data containing only data from models in shared_models. \n\nTakes care of metadata.\n\nArguments:\n\ndata: must have a dimension that contains 'member' or 'model'\nshared_models: models, which can either be on level of models or members of models \n\n('modelname#memberID[_grid]').\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.summarizeMembers!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.Data.summarizeMembers!","text":"summarizeMembers!(data::DataMap; fn::Function=Statistics.mean)\n\nSet values for every dataset in data to the average across all members of  each model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.summarizeMembers-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Home","title":"ModelWeights.Data.summarizeMembers","text":"summarizeMembers(data::DataMap; fn::Function=Statistics.mean)\n\nReturn new DataMap containing every dataset in data summarized by applying fn  (default: mean) to all members of each model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.summarizeMembers-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.summarizeMembers","text":"summarizeMembers(data::YAXArray; fn::Function=Statistics.mean)\n\nFor each model compute a summary statistic (default: mean) across all its members. \n\nThe returned YAXArray has dimension 'model'.\n\nArguments:\n\ndata::YAXArray: YAXArray; must have dimension 'member'\nupdateMeta::Bool: set true if the vectors in the metadata refer to \n\ndifferent models. Set to false if vectors refer to different variables.\n\nfn::Function: Function to be applied on data\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.summarizeMembersMatrix-Tuple{YAXArrays.Cubes.YAXArray, Bool}","page":"Home","title":"ModelWeights.Data.summarizeMembersMatrix","text":"summarizeMembersMatrix(data::AbstractArray, updateMeta::Bool; fn::Function=Statistics.mean)\n\nCompute the average across all members of each model for each given variable  for model to model data, e.g. distances between model pairs.\n\nArguments:\n\ndata: with at least dimensions 'member1', 'member2'\nupdateMeta: set true if the vectors in the metadata refer to different models. \n\nSet to false if vectors refer to different variables for instance. \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.summarizeMembersVector-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Data.summarizeMembersVector","text":"summarizeMembersVector(data::YAXArray; fn::Function=Statistics.mean)\n\nFor each model compute a summary statistic (default: mean) across all its members.  The returned YAXArray has dimension :model (instead of :member).\n\nArguments:\n\ndata::YAXArray: YAXArray; must have dimension 'member' and at least one other arbitrary dimension \nfn::Function: Function to be applied on data\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.throwErrorIfDimMissing-Tuple{YAXArrays.Cubes.YAXArray, Symbol}","page":"Home","title":"ModelWeights.Data.throwErrorIfDimMissing","text":"throwErrorIfDimMissing(data::YAXArray)\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.throwErrorIfDimMissing-Tuple{YAXArrays.Cubes.YAXArray, Vector{Symbol}}","page":"Home","title":"ModelWeights.Data.throwErrorIfDimMissing","text":"throwErrorIfDimMissing(data::YAXArray, dims::Vector{Symbol}; include::Symbol=:all)\n\nThrow ArgumentError if data does not have ALL dimensions in dims when include=:all  (default), or if data does not have ANY dimension in dims.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.uncertaintyRanges-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.Data.uncertaintyRanges","text":"uncertaintyRanges(\n    data::AbstractArray; w::Union{DimArray, Nothing}=nothing, quantiles=[0.167, 0.833]\n)\n\nCompute weighted quantiles of timeseries data.\n\nArguments:\n\ndata::AbstractArray: must have dimensions 'time', 'model'.\nw::Union{DimArray, Nothing}=nothing: must have dimensions 'model' and 'weight', each \n\n'weight'-vector must sum up to 1.\n\nquantiles=[0.167, 0.833]: vector with two entries between 0 and 1 representing  the \n\nlower and upper bound in this order.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.updateGroupedDataMetadata-Tuple{Dict, DimensionalData.DimGroupByArray}","page":"Home","title":"ModelWeights.Data.updateGroupedDataMetadata","text":"updateGroupedDataMetadata(meta::Dict, grouped_data::DimensionalData.DimGroupByArray)\n\nSummarize vectors in meta, refering to different models (members), such that  each vector only contains N entries (N=number of models (i.e. without unique members)).\n\nIf the metadata for members of a model differ across members, the respective entry in the vector will be a vector itself.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Data.writeDataToDisk-Tuple{Any, String}","page":"Home","title":"ModelWeights.Data.writeDataToDisk","text":"writeDataToDisk(data, target_path::String)\n\nSave data as Julia obj if target_path has ending '.jld2', otherwise save as binary. If file at target_path already exists, timestamp is added if overwrite is false (default).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.convertKgsToSv!-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Plots.convertKgsToSv!","text":"convertKgsToSv!(vec:YAXArray)\n\nConvert data given in unit 'kg s-1' into Sverdrups (Sv).\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.getClosestGridPoint-Tuple{Dict, Vector, Vector}","page":"Home","title":"ModelWeights.Plots.getClosestGridPoint","text":"getClosestGridPoint(location::Dict, longitudes::Vector, latitudes::Vector)\n\nFind the grid point in grid defined by longitudes and latitudes that is closest to location.\n\nArguments\n\nlocation::Dict: 'lon', 'lat' of position for which closest grid point is\n\nreturned, lon must be given from -180° to 180°\n\nlongitudes::Vector: grid longitudes measured from -180° to 180°\nlatitudes::Vector: grid latitudes measured from -90° to 90°\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.latitude2NorthSouth-Tuple{Number}","page":"Home","title":"ModelWeights.Plots.latitude2NorthSouth","text":"latitude2NorthSouth(lat::Number)\n\nConvert latitudes from -90° to 90° into 0° to 90° North/South.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.lon180to360-Tuple{Number}","page":"Home","title":"ModelWeights.Plots.lon180to360","text":"lon360to180(lon::Number)\n\nConvert longitudes measured from -180° to 180° into 0° to 360° scale.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.lon360to180-Tuple{Number}","page":"Home","title":"ModelWeights.Plots.lon360to180","text":"lon360to180(lon::Number)\n\nConvert longitudes measured from 0° to 360° into  -180° to 180° scale.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.longitude2EastWest-Tuple{Number}","page":"Home","title":"ModelWeights.Plots.longitude2EastWest","text":"longitude2EastWest(lon::Number)\n\nConvert longitudes from -180° to 180° into 0° to 180° East/West.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.makeSubplots-Tuple{AbstractArray, @NamedTuple{nrows::Int64, ncols::Int64}}","page":"Home","title":"ModelWeights.Plots.makeSubplots","text":"makeSubplots\n\nArguments:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotAMOC-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Plots.plotAMOC","text":"plotAMOC(data::DimArray)\n\nPlot AMOC strength for variable \"amoc\".\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotDistances-Tuple{AbstractArray, String}","page":"Home","title":"ModelWeights.Plots.plotDistances","text":"plotDistances(dists::AbstractArray, title::String; is_bar_plot::Bool=true)\n\nPlot figure of distances for every combination of variable and diagnostic in  dists.\n\nArguments:\n\ndists: must have dimensions :variable, :diagnostic\ntitle:\nis_bar_plot:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotDistancesIndependence-Tuple{AbstractArray, String}","page":"Home","title":"ModelWeights.Plots.plotDistancesIndependence","text":"plotDistancesIndependence(distances::AbstractArray, dimname::String)\n\nArguments:\n\ndistances:\ndimname:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotEnsembleSpread-Tuple{YAXArrays.Cubes.YAXArray, Number, Number}","page":"Home","title":"ModelWeights.Plots.plotEnsembleSpread","text":"plotEnsembleSpread(data::AbstractArray, lon::Number, lat::Number)\n\nCreate figure with boxplots for each model in data that have several ensemble members.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotHistAtPos-Tuple{YAXArrays.Cubes.YAXArray, Dict}","page":"Home","title":"ModelWeights.Plots.plotHistAtPos","text":"plotHistAtPos(data::AbstractArray, location::Dict)\n\nPlot histogram of all data for a specific location.\n\nArguments:\n\ndata: dimensions 'lon' (from -180° to 180°), 'lat' (-90° to 90°)\nlocation: must have keys 'name', 'lon', 'lat'\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotTempGraph-Tuple{YAXArrays.Cubes.YAXArray, NamedTuple, NamedTuple, String}","page":"Home","title":"ModelWeights.Plots.plotTempGraph","text":"plotTempGraph\n\n# TODO: change quantileLabels and uncertaintyRanges, the latter should contain \n# the quantile labels\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotTimeseries!-Tuple{Makie.Axis, AbstractArray}","page":"Home","title":"ModelWeights.Plots.plotTimeseries!","text":"plotTimeseries!(ax::Axis, vals::AbstractArray;)\n\nPlot timeseries of data vector vals.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotValsOnMap!-Tuple{Makie.Figure, AbstractArray, String}","page":"Home","title":"ModelWeights.Plots.plotValsOnMap!","text":"plotValsOnMap!(fig::Figure, means::AbstractArray, title::String;                     colors=nothing, colorrange=nothing, highclip=(1,0,0),                     lowclip=(0,0,1), pos=(x=1, y=1), poslegend=nothing                     )\n\nPlot contours of world with an overlayed heatmap of the input data.\n\nArguments:\n\nnb_ticks: if nothing (default), just min lat/lon, max lat/lon and 0 are labeled.\npos::NamedTuple(x::Int,y::Int): position of plot in fig\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotWeightContributions-Tuple{DimensionalData.DimArray, DimensionalData.DimArray}","page":"Home","title":"ModelWeights.Plots.plotWeightContributions","text":"plotWeightContributions(independence::DimArray, performance::DimArray)\n\nPlot performance against independence weights.\n\nArguments:\n\nindependence: (dims:model) normalized independence weights\nperformance: (dims:model) normalized performance weights \n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.plotWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Plots.plotWeights","text":"plotWeights(weights::YAXArray; title::String=\"\", sort_by::String=\"\")\n\nPlot weights sorted by weight dimension sort_by of weights if given, otherwise, sorted by first value in weight dimension.\n\nEqual weights line is added to the plot.\n\nArguments:\n\nweights::YAXArray: with dimensions :weight and :model\ntitle::String:\nsort_by::String: value of weight dimension according to which data is sorted\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Plots.sortLongitudesWest2East-Tuple{AbstractArray}","page":"Home","title":"ModelWeights.Plots.sortLongitudesWest2East","text":"sortLongitudesWest2East(data::AbstractArray)\n\nArrange 'data' such that western latitudes come first, then eastern latitudes.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Timeseries.computeLinearTrend-Tuple{Vector, Vector}","page":"Home","title":"ModelWeights.Timeseries.computeLinearTrend","text":"computeLinearTrend(x::Vector, y::Vector; full_predictions::Bool = false)\n\nRegress y on x and return slope (default) or predicted y for every element in x (if full_predictions=true)\n\nArguments:\n\nx::Vector:\ny:Vector:\nfull_predictions::Bool: if false, return slope, otherwise return all values predicted for x.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Timeseries.filterTimeseries-Tuple{YAXArrays.Cubes.YAXArray, Number, Number}","page":"Home","title":"ModelWeights.Timeseries.filterTimeseries","text":"function filterTimeseries(\n    data::YAXArray,\n    start_year::Number,\n    end_year::Number;\n    only_models_non_missing_vals::Bool = true\n)\n\nArguments:\n\ndata::YAXArray:\nstart_year::Number: set to -Inf to not filter for start time.\nend_year::Number: set to Inf to not filter for end time.\nonly_models_non_missing_vals::Bool = true:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Timeseries.linearTrend-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Timeseries.linearTrend","text":"linearTrend(data::YAXArray; full_predictions::Bool=true)\n\nCompute linear trend as ordinary least squares for timeseries data and return slope  (default) or predicted y for every element in x (if full_predictions=true)\n\nArguments:\n\ndata::YAXArray: must have dimension :time.\nfull_predictions::Bool:\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.applyWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Weights.applyWeights","text":"applyWeights(model_data::YAXArray, weights::YAXArray)\n\nCompute the weighted average of model data data with given weights.\n\nIf weights were computed for a superset of the models in data, they are normalized and applied to the subset. Only weights per model (not members) are considered for now, in the future, members should be considered too.\n\nArguments:\n\nmodel_data::YAXArray: model predictions. If given for model members, the predictions \n\nof each model are considered the average value of all members of the respective model.\n\nweights::YAXArray: if given for each member of a model, these will be summed up to \n\nyield one value per model.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.climwipWeights-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Dict{String, YAXArrays.Cubes.YAXArray}, ModelWeights.Weights.ConfigWeights}","page":"Home","title":"ModelWeights.Weights.climwipWeights","text":"climwipWeights(\n    model_data::DataMap,\n    obs_data::DataMap,\n    config::ConfigWeights;\n    suffix_name::String = \"historical\"\n)\n\nCompute ClimwipWeights based on RMSE distances between observational data and model-model pairs.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.climwipWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, ModelWeights.Weights.ConfigWeights}","page":"Home","title":"ModelWeights.Weights.climwipWeights","text":"climwipWeights(\n    dists_indep_all::YAXArray, \n    dists_perform_all::YAXArray,\n    config::ConfigWeights;\n    suffix_name::Stirng = \"climwip\"\n)\n\nCompute weight for each model in multi-model ensemble according to approach from Brunner, Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020. \n\nArguments:\n\ndists_indep_all::YAXArray: RMSEs between pairs of models for all \n\ncombinations of variables and diagnostics; has dimensions 'member1', 'member2', 'variable',  'diagnostic'.\n\ndists_perform_all::YAXArray: RMSEs between model and observational data for all \n\ncombinations of variables and diagnostics; has dimensions 'member', 'variable', 'diagnostic'.\n\nconfig::ConfigWeights: Parameters specifiying the relative contributions of each \n\ncombination of variable and diagnostic.\n\nsuffix_name::String: added to name of each type of weights, s.t. names are: wP-suffix, \n\nwI-suffix, combined-suffix (default 'climwip').\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.distributeWeightsAcrossMembers-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Home","title":"ModelWeights.Weights.distributeWeightsAcrossMembers","text":"distributeWeightsAcrossMembers(weights::YAXArray, members::Vector{String})\n\nEqually distribute weight for each model over its members.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.equalWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Weights.equalWeights","text":"equalWeights(data::YAXArray; use_members::Bool=true)\n\nCreate a weight vector, with equal weight for each MODEL. Distribute weight across model members if dimension=:member and usemembers is true. If usemember is false,  each model member is considered as standalone model and all receive the same weight.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.independenceWeights-Tuple{YAXArrays.Cubes.YAXArray, Number}","page":"Home","title":"ModelWeights.Weights.independenceWeights","text":"independenceWeights(Sij::YAXArray, sigmaS::Number)\n\nCompute the independence weight for each model i with generalized distances between pairs of models, Sij.\n\nw^I_i = a_0 cdot frac11 + sum_j ne i e^-left( fracS_ijsigma_S right)^2\n\nArguments:\n\nSij: generalized distances for each pair of models with dimensions 'model1', 'model2'\nsigmaS: free shape parameter for impact of independence weights\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.performanceWeights-Tuple{YAXArrays.Cubes.YAXArray, Number}","page":"Home","title":"ModelWeights.Weights.performanceWeights","text":"performanceWeights(Di::AbstractArray, sigmaD::Number)\n\nCompute the ClimWIP performance weight for each model i with generalized distances Di.\n\nw^P_i = a_0 cdot frace^-(fracD_isigma_D)^2N\n\nArguments:\n\nDi::YAXArray: generalized distances Di for each model\nsigmaD::Number: free shape parameter for impact of performance weights\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.saveWeightsAsNCFile-Tuple{ModelWeights.Weights.ClimWIP, String}","page":"Home","title":"ModelWeights.Weights.saveWeightsAsNCFile","text":"saveWeightsAsNCFile(weights::ClimWIP; target_path::String)\n\nTODO: needs to be updated, deprecated\n\nArguments:\n\nweights: ClimWIP object to be saved.\ntarget_path: Path to where weights shall be stored.\n\n\n\n\n\n","category":"method"},{"location":"#ModelWeights.Weights.weightedAvg-Tuple{YAXArrays.Cubes.YAXArray}","page":"Home","title":"ModelWeights.Weights.weightedAvg","text":"weightedAvg(\n    data::YAXArray; \n    weights::Union{YAXArray, Nothing} = nothing, \n    use_members_equal_weights::Bool = true\n)\n\nCompute the average values for each (lon,lat) grid point in data, weighted by weights. \n\nIf no weight vector is provided, unweighted average is computed.\n\nArguments:\n\ndata::YAXArray: must have dimension 'model' or 'member'\nweights::Union{YAXArray, Nothing} = nothing: weights for models or individual members\nuse_members_equal_weights::Bool:  if weights is nothing, all models receive \n\nequal weight. Then, if use_members_equal_weights is true, the number of members  per model is taken into account, e.g. [\"m1#run1\", \"m1#run2\", \"m1#run3\", \"m2#run1\"] yields  [1/4, 1/4, 1/4, 1/4] if use_members_equal_weights = false and if  use_members_equal_weights = true, [1/2 * 1/3, 1/2 * 1/3, 1/2 * 3, 1/2] = [1/6, 1/6, 1/6, 1/2].\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
