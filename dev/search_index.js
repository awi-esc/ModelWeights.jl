var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting started","title":"Installation","text":"For now, ModelWeights.jl should be used like any local package under development:\n\nClone the repository to a local directory.\nAdd ModelWeights.jl to your workspace in Julia using Pkg.dev() rather than Pkg.add():\n\nusing Pkg; Pkg.dev(\"path/to/ModelWeights.jl\")\n\nNow use it like a normal package. If you will make changes to it, then consider also\n\nloading Revise.jl (and do so before using ModelWeights.jl):\n\nusing Revise\nusing ModelWeights","category":"section"},{"location":"getting-started/#Basics","page":"Getting started","title":"Basics","text":"","category":"section"},{"location":"getting-started/#Quickstart-Loading/Filtering-Data","page":"Getting started","title":"Quickstart Loading/Filtering Data","text":"Load different datasets into a DataMap\n\nimport ModelWeights as mw\n\npaths_ds1 = [\"test/data/lgm-cmip6-tas-climatologies\", \"test/data/lgm-cmip5-tas-climatologies\"]\npaths_ds2 = [\"test/data/lgm-cmip6-tos-climatologies\"]\nids = [\"lgm_tas_CLIM\", \"lgm_tos_CLIM\"]\ndm = mw.defineDataMap([paths_ds1, paths_ds2], ids; filename_format = :esmvaltool)\n\nSubset data so that every dataset contains the same models (but not necessarily the same model members):\n\ndm_models = mw.subsetModelData(dm, :model)\n\nSubset data so that every dataset contains the same model simulations:\n\ndm_members = mw.subsetModelData(dm, :member)\n\nThe same filtering can be done directly when loading the data: \n\nconstraint = Dict(\n    \"level_shared\" => :member\n)\ndm_members2 = mw.defineDataMap([paths_ds1, paths_ds2], ids; constraint, filename_format = :esmvaltool)\n\nTo get the shared models/members:\n\nmodels_shared = mw.sharedModels(dm, \"model\")\nmembers_shared = mw.sharedModels(dm, \"member\")","category":"section"},{"location":"getting-started/#Quickstart-Manipulating-Data","page":"Getting started","title":"Quickstart Manipulating Data","text":"To conveniently apply any function that takes as first argument a YAXArray, to every (or a subset) of datasets in a DataMap, you can use the functions apply or apply!. While apply returns a new DataMap, apply! modifies the input DataMap. Both provide keyword arguments ids and ids_new. If ids is not provided, the function is applied to every dataset in the input DataMap and if ids_new is not provided, the new names will be identical to the old names. That is, if they are not specified and apply! is used the respective entries are overwritten.\n\nFor example, to compute (area weighted) global means for all datasets:\n\nmw.Data.apply(dm_members, mw.Data.globalMeans)\n\nfor a subset, modifying original DataMap:\n\nmw.Data.apply!(dm_members, mw.Data.globalMeans; ids = [\"lgm_tas_CLIM\"], ids_new = [\"lgm_tas_GM\"])\n\nThe first argument to apply (or apply!) is always the DataMap, the second the function that takes as first argument a YAXArray, followed by the positional and then possibly keyword arguments that the function expects.","category":"section"},{"location":"getting-started/#Quickstart-Weights","page":"Getting started","title":"Quickstart Weights","text":"Let's first create some random (non realistic) observational data (with the same grid as in the model data!) and load it into a DataMap:\n\nusing DimensionalData\nusing YAXArrays\n\nlongitudes = collect(lookup(dm_models[\"lgm_tas_CLIM\"], :lon))\nlatitudes = collect(lookup(dm_models[\"lgm_tas_CLIM\"], :lat))\n\nobs_tas = YAXArray((\n    Dim{:lon}(longitudes), Dim{:lat}(latitudes), Dim{:model}([\"obs\"])),\n    rand(length(longitudes), length(latitudes), 1)\n)\nobs_tos = YAXArray((\n    Dim{:lon}(longitudes), Dim{:lat}(latitudes), Dim{:model}([\"obs\"])),\n    rand(length(longitudes), length(latitudes), 1)\n)\ndm_obs = mw.defineDataMap([obs_tas, obs_tos], [\"tas_CLIM\", \"tos_CLIM\"])\n\nWe need to specify the diagnostics that the performance and independence weights should be based on as well as the relative impact of each and the hyperparameters sigma_D sigma_S that respectively regulate the strength of the performance- and independence weighting.\n\nNote that the diagnostics for the distances between models and data must all be defined on a lon x lat grid.\n\nconfig = mw.Weights.ConfigWeights(\n    performance = Dict(\n        \"tas_ANOM-GM\" => 1,\n        \"tos_ANOM-GM\" => 1\n    ),\n    independence = Dict(\n        \"lgm_tas_CLIM\" => 0.5,\n        \"lgm_tos_CLIM\" => 0.5\n    ),\n    sigma_independence = 0.5, # may be ommited (0.5 is default value)\n    sigma_performance = 0.5 # may be ommited (0.5 is default value)\n);\n\nLet's compute the diagnostics we haven't computed yet that we just specified, the anomalies with respect to the global mean (denoted as \"ANOM-GM\"). For model data:\n\nids = collect(keys(dm_models))\nids_new = map(x -> replace(x, \"CLIM\" => \"ANOM-GM\"), ids)\nmw.Data.apply!(dm_models, mw.Data.anomaliesGM; ids, ids_new)\n\nAnd for observational data:\n\nids = collect(keys(dm_obs))\nids_new = map(x -> replace(x, \"CLIM\" => \"ANOM-GM\"), ids)\nmw.Data.apply!(dm_obs, mw.Data.anomaliesGM; ids, ids_new)\n\nBefore we can compute weights, we need to make sure that the keys for the observations and models for the diagnostics are identical:\n\nmw.Data.renameDict!(\n    dm_models,\n    [\"lgm_tas_ANOM-GM\", \"lgm_tos_ANOM-GM\"],\n    [\"tas_ANOM-GM\", \"tos_ANOM-GM\"]\n)\n\nNow, we're ready to compute model weights:\n\nweights = mw.Weights.climwipWeights(dm_models, dm_obs, config)","category":"section"},{"location":"examples/climwip/#Climwip-example-from-Brunner-et-al.-(2020)","page":"Climwip example from Brunner et al. (2020)","title":"Climwip example from Brunner et al. (2020)","text":"","category":"section"},{"location":"weights/#Model-weights","page":"Model weights","title":"Model weights","text":"The weighting method that we use was developed by Knutti et al. (2017) that is based on work from Sanderson et al. (2015) (see References).","category":"section"},{"location":"weights/#Basic-computation-of-weights","page":"Model weights","title":"Basic computation of weights","text":"The overall weight for model i is computed based on its performance- and independenct weights, w^P_i and w^I_i:\n\nw_i = a_0 cdot w^P_i cdot w^I_i \n\nThe performance and independence weights are defined as follows: \n\nw^P_i = a_1 cdot e^-(fracD_isigma_D)^2\n\nw^I_i = a_2 cdot frac1sum_j e^-left( fracS_ijsigma_S right)^2 \n\nS_ij\n\nrefers to the generalized distances between models i and j and D_i refers to the generalized distances between predictions of model i and observatioanl/reanalysis data sigma_S and sigma_D are hyperparameters that specify the strength of the independence- and performance weighting respectively and a_0 a_1 a_2 are normalization constants.","category":"section"},{"location":"Manual/computing-weights/#Computing-weights","page":"Computing weights","title":"Computing weights","text":"For a full example, see scripts/run-climwip-simplified.yml.\n\nCalling mw.computeWeights(dists_indep, dists_perform, config) will compute weights based on the distances for the independence weights and the distances for the performance weights. The config parameter is of type ConfigWeights defined in src/data-utils.jl. It holds information about the contribution of each combination of statistic/diagnostic and climate variable, once for computing independence weights and once for computing performance weights. Further parameters concerning the weighting are specified in the ConfigWeights struct, such as the hyperparameters,  sigma_performance and sigma_independence. \n\nThe output of the function `computeWeights` is an object of type `Weights` (see `src/data-utils.jl`) which contains the independence and performance weights seperately as well as the overall weights (`wI`, `wP` and `w`), each of which respectively sum up to 1. Further it contains the following data:\n- For all combinations of statistics/diagnostics and climate variables, the distances used for computing performance as well as independence weights (`performance_distances`, `independence_distances`). \n- For every model, the generalized distances for performance (`Di`) and independence (`Sij`), (distances summed across statistics/diagnostics + variables).\n- Model weights on the basis of members, i.e. the weight for every model is distributed evenly across its members, so this gives one weight per member.\n- the configuration in form of the `ConfigWeights` object used to compute the weights.\n\n\n\n@raw html <!– weights_variables:: For each of 'performance' and 'independence' one value per climate variable considered. These values represent the weight of how much each climate variable influences the generalized distance of a model, which is computed by taking a weighted average across the distances with respect to different variables. Should sum up to 1.  –> ```\n\n<!– julia import ModelWeights as mw weights = mwcomputeWeights(model_data_historical obs_data config_weights)\n\nThe Weights object has several fields that each store a DimensionalData.DimArray. Some of them refer to normalized weights, others refer  to the distances on the basis of which the weights were computed.\n\nperformance_distances and independence_distances contain the distances\n\nbetween models and data (performance) or between models and models (independence)  for every combination of variable and diagnostic/statistic.\n\nDi and Sij are the generalized distances, i.e. weighted average of all\n\ndistances across variables and diagnostic. So, D_i is a vector with size  1xn where n is the number of models (not on level of members!) and S_ij is  a matrix of size n x n. \n\nwP and wI respectively store the normalized performance/independence weights, \n\nboth have size 1xn (n: number of models).\n\nw is the overall weight vector of length n. –>\n\ns","category":"section"},{"location":"reference/API/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"reference/API/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"reference/API/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"reference/API/#ModelWeights.Data.add-Tuple{YAXArrays.Cubes.YAXArray, Symbol}","page":"Public API","title":"ModelWeights.Data.add","text":"add(data::YAXArray, dimension::Symbol)\n\nWrapper function for sum that removes 'dimension' from the returned YAXArray.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.alignPhysics-Tuple{YAXArrays.Cubes.YAXArray, AbstractVector{String}}","page":"Public API","title":"ModelWeights.Data.alignPhysics","text":"alignPhysics(data::YAXArray, members::Vector{String})\n\nReturn new YAXArray with the models retained from data that share the same physics as  the respective model's members in members. All other models that are in data but for which no member is specified in members are  also retained.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.anomalies-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.anomalies","text":"anomalies(orig_data::YAXArray, ref_data::YAXArray)\n\nCompute difference of orig_data and ref_data.  \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.apply-Union{Tuple{T}, Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Function, Vararg{Any}}} where T<:Union{String, Symbol}","page":"Public API","title":"ModelWeights.Data.apply","text":"apply(\n    dm::DataMap,\n    fn::Function,\n    args...; \n    ids::AbstractVector{T} = Vector{String}(),\n    ids_new::AbstractVector{T} = Vector{String}(),\n    kwargs...\n)\n\nApply fn with positional arguments args and keyword arguments  kwargs and return result as a new DataMap where keys are ids_new if provided, otherwise same keys as in dm are used.\n\nArguments:\n\ndm::DataMap: data.\nfn::Function: function to be applied.\nargs...: positional arguments for fn.\nids::AbstractVector{T}=Vector{String}(): keys for data on which fn is applied; if empty all keys of dm are used.\nids_new::AbstractVector{T}=Vector{String}(): keys used in new datamap; if empty ids are used instead.\nkwargs...: keyword arguments for fn.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.areaWeightMatrix-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray{Bool}}} where T<:Number","page":"Public API","title":"ModelWeights.Data.areaWeightMatrix","text":"areaWeightMatrix(\n    latitudes::AbstractVector{<:Number}, mask::YAXArray{T}\n) where {T <: Union{Missing, Bool}}\n\nReturn matrix of size length(longitudes) x length(latitudes) with normalized area weights  (approximated based on latitudes) and set to 0 at positions where mask is true.\n\nArguments:\n\nlatitudes::AbstractVector{<:Number}: to approximate area weights with cosine of latitudes.\nmask::AbstractArray{T}: lon, lat as first and second dimension respectively where lat must \n\nhave same length as latitudes.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.areaWeightedMSE-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"Public API","title":"ModelWeights.Data.areaWeightedMSE","text":"areaWeightedMSE(m1::AbstractArray, m2::AbstractArray, aw_mat::AbstractArray)\n\nCompute the area weighted (approximated by cosine of latitudes in radians) mean squared  error between m1 and m2.\n\nArguments:\n\nm1: must have dimensions 'lon', 'lat' as first dimensions.\nm2: must have dimensions 'lon', 'lat' as first dimensions.\naw_mat: matrix with area weights, of same size as m1 and m2, that will be normalized.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.areaWeightedRMSE-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"Public API","title":"ModelWeights.Data.areaWeightedRMSE","text":"areaWeightedRMSE(m1::AbstractArray, m2::AbstractArray, aw_mat::AbstractArray)\n\nCompute the area weighted (approximated by cosine of latitudes in radians) root mean squared  error between m1 and m2. \n\nArguments:\n\nm1: must have dimensions 'lon', 'lat' as first dimensions.\nm2: must have dimensions 'lon', 'lat' as first dimensions.\naw_mat: matrix with area weights, of same size as m1 and m2, that will be normalized.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.average-Tuple{YAXArrays.Cubes.YAXArray, Symbol}","page":"Public API","title":"ModelWeights.Data.average","text":"average(data::YAXArray, dimension::Symbol)\n\nWrapper function for mean that removes 'dimension' from the returned YAXArray.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.avgObsDatasets-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.avgObsDatasets","text":"avgObsDatasets(observations::YAXArray)\n\nTake mean across dimension 'model'. Returned YAXArray does not have dimension 'model'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.checkConstraint-Tuple{Union{Nothing, Dict}}","page":"Public API","title":"ModelWeights.Data.checkConstraint","text":"checkConstraint(constraint::Union{Dict, Nothing})\n\nThrow error if entries (except for level_shared) do not map to a vector of Strings.\n\nUsed to provide specific error messages of values that were not specified correctly.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.combineAll-Tuple{Vararg{Vector{String}}}","page":"Public API","title":"ModelWeights.Data.combineAll","text":"combineAll(v::Vararg{Vector{String}}; sep::String=\"_\")\n\nGenerate vector with all possible combinations of strings, each of which is a concatenation  of elements from each input vector in the given order, concatenated by sep (default: _).\n\nArguments\n\nv::Vararg{Vector{String}}: A variable number of input vectors.\nsep::String: seperator\n\nExample\n\njulia> ModelWeights.Data.combineAll([\"tos\", \"tas\"], [\"CLIM\"])\n2-element Vector{String}:\n \"tos_CLIM\"\n \"tas_CLIM\"\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.combineModelsFromMultipleFiles-Union{Tuple{AbstractVector{<:AbstractArray}}, Tuple{T}} where T","page":"Public API","title":"ModelWeights.Data.combineModelsFromMultipleFiles","text":"combineModelsFromMultipleFiles(\n    data::Vector{AbstractArray}; \n    model_names::Vector{String} = Vector{String}(),\n    meta::Union{Dict{String, T}, Nothing} = nothing,\n    dtype::String = \"undef\",\n    new_dim::Symbol = :model,\n    sorted::Bool = true\n\n) where T <: Any\n\nCombine data from different files into a single YAXArray.  The meta data of the returned YAXArray is a combination of all values from all datasets  using vectors with missing values for datasets that didn't have the respective metadata  entry in their metadata, further combined with the properties in meta if provided.\n\nAll elements in data must share all dimensions except for time (if present). For timeseries data, the time dimension may cover different ranges. In that case the  maximal overlapping time period is used.\n\nThe combined YAXArray has the additional dimension new_dim (default: :model) with names as values. If names is not provided, default values 'model1', 'model2, etc. are used  instead.\n\nIf sorted is true, model dimension of returned data is sorted alphabetically and the  vector entries in the metadata dictionary of the returned array are also sorted accordingly.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.constrainMetaData!-Tuple{Vector{ModelWeights.Data.MetaData}, Dict}","page":"Public API","title":"ModelWeights.Data.constrainMetaData!","text":"constrainMetaData!(meta_attributes::Vector{MetaData}, constraint::Dict)\n\nSubset entries in meta_attributes so that only those with properties specified  in constraint remain.\n\nArguments\n\nconstraint::Dict: Mapping to vector specifiying the properties of which at least one \n\nmust be present for an id to be retained.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.convertToYAX-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Public API","title":"ModelWeights.Data.convertToYAX","text":"convertToYAX(dm::DataMap; dim_name::Symbol = :diagnostic)\n\nConvert a DataMap into a YAXArray. All entries in dm must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{String}, String}} where T","page":"Public API","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    path_data_dir::String, \n    id::String;\n    meta_data::Dict{String, T} = Dict{String, Any}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"cmip\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entry id with the data (model and/or obs depending on dtype) from  all .nc files in paths and all .nc files in all directories in paths, possibly  constraint by constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{String}, Vector{String}}} where T","page":"Public API","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    paths_data_dirs::Vector{String}, \n    data_ids::Vector{String};\n    meta_data::Vector{Dict{String, T}} = Vector{Dict{String, Any}}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"cmip\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entries data_ids with the data (model and/or obs depending on dtype)  from all .nc files in all directories in paths_data_dirs, possibly constraint by constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.defineDataMap-Union{Tuple{T}, Tuple{Vector{Vector{String}}, Vector{String}}} where T","page":"Public API","title":"ModelWeights.Data.defineDataMap","text":"defineDataMap(\n    paths_data_dirs::Vector{String}, \n    data_ids::Vector{String};\n    meta_data::Vector{Dict{String, T}} = Vector{Dict{String, Any}}(),\n    constraint::Union{Dict, Nothing} = nothing,\n    sorted::Bool = true, \n    dtype::String = \"cmip\",\n    filename_format::Union{Symbol, String} = :cmip\n) where T <: Any\n\nReturn DataMap with entries data_ids with the data (model and/or obs depending on dtype)  from all .nc files in all directories in paths_dirs, possibly constraint by constraint.\n\nFor every loaded dataset (entry in built DataMap), files are loaded from several directories; each entry in paths_data_dirs points the the vector of data directories from where data  is loaded for that dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.dict2YAX-Union{Tuple{Dict{String, T}}, Tuple{T}} where T<:Number","page":"Public API","title":"ModelWeights.Data.dict2YAX","text":"dict2YAX(data::Dict{String, <:Number})\n\nConvert dictionary data into a YAXArray with new dimension dim_name  (default is :diagnostic) whose lookup names are the keys of data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.dimNames-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.dimNames","text":"dimNames(data::YAXArray)\n\nReturn the names of the dimensions of data as vector of symbols.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesData-Tuple{AbstractArray, AbstractArray, AbstractArray{<:Real}}","page":"Public API","title":"ModelWeights.Data.distancesData","text":"distancesData(\n    model_data::AbstractArray, \n    obs_data::AbstractArray,\n    model_names::AbstractArray{<:String},\n    latitudes::AbstractArray{<:Real}; \n    metric::Symbol=:rmse\n)\n\nCompute the distance as the area-weighted RMSE (default) or MSE between model predictions and observations.\n\nArguments:\n\nmodel_data::AbstractArray: dimensions must be 'lon', 'lat' and 'model'/'member' in 3rd dimension.\nobs_data::AbstractArray: dimensions must be 'lon', 'lat'.\nlatitudes::AbstractArray{<:Real}: values of latitudes in model_data and obs_data. \nmetric::Symbol: :rmse for Root Mean Squared Error (default) or :mse for Mean Squared Error,\nidx_model::Int: number of model/member-dimension in model_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesData-Tuple{AbstractArray, AbstractArray, AbstractVector}","page":"Public API","title":"ModelWeights.Data.distancesData","text":"distancesData(\n    models::AbstractArray, observations::AbstractArray, latitudes::AbstractVector\n)\n\nCompute the distance as the area-weighted RMSE between model predictions and observations.\n\nNeither the observations nor the model data must contain missing values.\n\nArguments:\n\nmodels: dimensions must be 'lon', 'lat', 'model'/'member' (in this order)\nobservations: dimensions must be 'lon', 'lat' (in this order)\nlatitudes: for computing area weight matrices\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesData-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Public API","title":"ModelWeights.Data.distancesData","text":"distancesData(model_data::DataMap, obs_data::DataMap, diagnostics::Vector{String})\n\nCompute RMSEs between models and observations for diagnostics.\n\nArguments:\n\ndiagnostics::Vector{String}: keys for which values must be provided in model_data and \n\nobs_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesData-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.distancesData","text":"distancesData(models::YAXArray, observations::YAXArray)\n\nCompute the distance as the area-weighted RMSE between model predictions and observations.\n\nIf `observations' has dimension 'model' (for several observational datasets), the average across all is taken.\n\nArguments:\n\nmodels::YAXArray: dimensions must be 'lon', 'lat', 'model'/'member'.\nobservations::YAXArray: dimensions must be 'lon', 'lat' and possibly 'model'.\nmetric::Symbol: :rmse for Root Mean Squared Error (default) or :mse for Mean Squared Error\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesModels-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Public API","title":"ModelWeights.Data.distancesModels","text":"distancesModels(model_data::DataMap, diagnostics::Vector{String})\n\nCompute the model-model distances for model_data at every diagnostic in diagnostics and  return a vector of YAXArrays.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.distancesModels-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.distancesModels","text":"distancesModels(data::YAXArray)\n\nCompute the area weighted RMSE between model predictions for each pair of models.\n\nArguments:\n\ndata::YAXArray: first two dimensions must be 'lon', 'lat', third 'model' or 'member'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.filterPathsSharedModels-Tuple{Vector{String}, Vector{String}, Union{String, Symbol}}","page":"Public API","title":"ModelWeights.Data.filterPathsSharedModels","text":"filterPathsSharedModels(\n    paths::Vector{String}, \n    shared_models::Vector{String}, \n    fn_format::Union{Symbol, String}\n)\n\nEvery vector of paths in all_paths is filtered s.t. it only contains models or model  members given in shared_models.\n\nArguments:\n\npaths: contains paths to data files\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.filterPathsSharedModels-Tuple{Vector{Vector{String}}, ModelWeights.Data.Level, Union{String, Symbol}}","page":"Public API","title":"ModelWeights.Data.filterPathsSharedModels","text":"filterPathsSharedModels(\n    all_paths::Vector{Vector{String}}, \n    level_shared::Level, \n    fn_format::Union{Symbol, String}\n)\n\nArguments:\n\nall_paths: every entry refers to the paths to data files for the respective dataset\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.generalizedDistances-Tuple{Vector{<:YAXArrays.Cubes.YAXArray}, Vector{String}, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.generalizedDistances","text":"generalizedDistances(\n    distances_all::Vector{<:YAXArray}, diagnostics::Vector{String}, weights::YAXArray\n)\n\nArguments:\n\ndistances_all::Vector{<:YAXArray}: each entry refers to the distances of one diagnostic, \n\neach must have dimension 'model', 'member' or 'member1' and 'member2' (must be identical for  every entry!).\n\ndiagnostics:: Vector{String}: names of diagnostics.\nweights::YAXArray: weights assigned to each diagnostic.\nnorm_avg_members::Bool: if true (default), average distances per model are computed \n\nBEFORE computing the median that is used to normalize the distances (seperately for each  diagnostic); if false, median is computed across all individual members of each diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.generalizedDistances-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.generalizedDistances","text":"generalizedDistances(\n    distances_all::YAXArray, weights::YAXArray; norm_avg_members::Bool = true\n)\n\nFor every diagnostic in distances_all, compute the weighted sum of all diagnostics.\n\nArguments:\n\ndistances_all::YAXArray: must have dimension :diagnostic.\nweights::YAXArray: weights assigned to each diagnostic.\nnorm_avg_members::Bool: if true (default), average distances per model are computed \n\nBEFORE computing the median that is used to normalize the distances (seperately for each  diagnostic); if false, median is computed across all individual members of each diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.getAtModel-Tuple{YAXArrays.Cubes.YAXArray, Symbol, String}","page":"Public API","title":"ModelWeights.Data.getAtModel","text":"getAtModel(data::YAXArray, dimension::Symbol, model::String)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.getByIdxModel-Tuple{YAXArrays.Cubes.YAXArray, Symbol, Vector}","page":"Public API","title":"ModelWeights.Data.getByIdxModel","text":"getByIdxModel(data::YAXArray, dimension::Symbol, indices::Vector)\n\nReturn data where dimension (member or model) has value model.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.getCMIPModelsKey-Tuple{Dict}","page":"Public API","title":"ModelWeights.Data.getCMIPModelsKey","text":"getCMIPModelsKey(meta::Dict)\n\nReturn the respective key to retrieve model names in CMIP6 ('sourceid') and  CMIP5 ('modelid') data.\n\nIf both keys are present, 'source_id' used in CMIP6 models is returned, if none  is present, throw ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.globalMeans-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.globalMeans","text":"globalMeans(data::YAXArray)\n\nReturn a YAXArray with area-weighted global means for each model in data. \n\nMissing data is accounted for in the area-weights. \n\nArguments:\n\ndata::YAXArray: must have dimensions 'lon' and 'lat'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.indexModel-Union{Tuple{N}, Tuple{YAXArrays.Cubes.YAXArray, NTuple{N, Symbol}, Vector{Int64}}} where N","page":"Public API","title":"ModelWeights.Data.indexModel","text":"indexModel(data::YAXArray, model_dims::Tuple{Symbol}, indices::Vector{Int})\n\nReturn data at model dimensions model_dims at indices.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.indicesTimeseries-Tuple{Vector{Dates.DateTime}, Dict}","page":"Public API","title":"ModelWeights.Data.indicesTimeseries","text":"indicesTimeseries(times::Vector, constraint_ts::Dict)\n\nGet indices of times that are exactly aligned with start_y and end_y given in constraint_ts. If no values are given, return indices for entire vector times.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.individuatePath-Tuple{String}","page":"Public API","title":"ModelWeights.Data.individuatePath","text":"individuatePath(target::String)\n\nIf file at target path exists, concatenate target with current timestep, otherwise  simply return target.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.joinDicts-Tuple{Vararg{Dict}}","page":"Public API","title":"ModelWeights.Data.joinDicts","text":"joinDicts(v::Dict...; warn_msg::String=\"\")\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.kelvinToCelsius-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.kelvinToCelsius","text":"kelvinToCelsius(data::YAXArray)\n\nReturn a copy of data with values given in Kelvin covnerted into Degree Celsius.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.loadDataFromESMValToolRecipes-Tuple{String, String}","page":"Public API","title":"ModelWeights.Data.loadDataFromESMValToolRecipes","text":"loadDataFromESMValToolRecipes(\n    path_data::String,\n    path_recipes::String;\n    dir_per_var::Bool = true,\n    constraint::Union{Dict, Nothing} = nothing,\n    preview::Bool = false,\n    sorted::Bool = true\n)\n\nLoad the data from the ESMValTool recipes at path_recipes or, if preview is true, load meta data only.\n\nArguments:\n\npath_data: top level directory were data is stored.\npath_recipes: directory were ESMValTool recipes are stored; these must be the versions \n\nin the run folder generated by ESMValTool named  RECIPENAME_filled.yml.\n\ndir_per_var: set to true (default) if there is a subdirectory in path_data for every \n\nclimate variable to be loaded.\n\nconstraint: TODO!\npreview: set to true if only meta data should be loaded (default: false).\nsorted: if true (default), the data is sorted alphabetically wrt model names.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.loadDataFromYAML-Tuple{Dict}","page":"Public API","title":"ModelWeights.Data.loadDataFromYAML","text":"loadDataFromYAML(\n    content::Dict;\n    constraint::Union{Dict, Nothing} = nothing,\n    preview::Bool = false,\n    sorted::Bool = true,\n    dtype::String = \"cmip\"\n)\n\nReturn a DataMap-instance that contains the data specified in content, potentially  constraint by values in constraint.\n\nArguments:\n\npreview::Bool: if true (default: false), return metadata and corresponding paths without \n\nactually loading any data.\n\nsorted::Bool: if true (default), model dimension is sorted alphabetically.\ndtype::String: if set to \"cmip\", model dimension of returned data have model names as values.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.loadDataMapCore-Tuple{Vector{Vector{String}}, Vector{String}, Vector{<:Dict}}","page":"Public API","title":"ModelWeights.Data.loadDataMapCore","text":"loadDataMapCore(\n    all_paths::Vector{Vector{String}},\n    ids::Vector{String},\n    constraints::Vector{Dict};\n    dtype::String = \"cmip\",\n    filename_format::Union{Symbol, String} = :cmip,\n    sorted::Bool = true,\n    preview::Bool = false,\n    meta_data::Union{Vector{Dict{String, T}}, Nothing} = nothing\n) where T <: Any\n\nLoad a DataMap instance with keys ids that map to data at all_paths, where every  subvector refers the the paths of the data of a single dataset. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.loadModelsFromCSV-Tuple{String, String}","page":"Public API","title":"ModelWeights.Data.loadModelsFromCSV","text":"loadModelsFromCSV(\n    path::String, col_models::String; col_variants::Union{String,Nothing}=nothing\n)\n\nReturn a vector with models retrieved from csv file at path. If col_variants is provided,  returned models are on level of model members (MODEL#variant, e.g. AWI-ESM#r1i1p1f1).\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.loadPreprocData-Union{Tuple{T}, Tuple{Vector{String}, Union{String, Symbol}}} where T","page":"Public API","title":"ModelWeights.Data.loadPreprocData","text":"loadPreprocData(\n    paths::Vector{String},\n    filename_format::Union{Symbol, String};\n    sorted::Bool = true, \n    dtype::String = \"cmip\",\n    names::Vector{String} = Vector{String}(),\n    meta_info::Union{Dict{String, T}, Nothing} = nothing,\n    constraint_ts::Union{Dict, Nothing} = nothing\n) where T <: Any\n\nReturn data loaded from paths as single YAXArray. \n\nEach path points to a different model, i.e. the data for one dataset is loaded from multiple  files and all datasets in paths must share the same dimensions. Which variable is loaded  is inferred from the filenames (in paths), or if meta_info has key 'variable', the  respective value is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.lon180to360-Tuple{Number}","page":"Public API","title":"ModelWeights.Data.lon180to360","text":"lon180to360(lon::Number)\n\nConvert longitudes measured from -180° to 180° into 0° to 360° scale. For western hemisphere  (negative longitudes) add 360.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.lon360to180-Tuple{Number}","page":"Public API","title":"ModelWeights.Data.lon360to180","text":"lon360to180(lon::Number)\n\nConvert longitudes measured from 0° to 360° into  -180° to 180° scale.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.longitudesEastWest-Tuple{AbstractArray}","page":"Public API","title":"ModelWeights.Data.longitudesEastWest","text":"sortLongitudesWest2East(data::AbstractArray)\n\nArrange 'data' such that western latitudes come first, then eastern latitudes.\n\nReturn NamedTuple with fields 'east' and 'west' pointing to vectors of indices for sorted longitudes.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.memberIDFromFilenameMeta-Tuple{ModelWeights.Data.FilenameMeta, String}","page":"Public API","title":"ModelWeights.Data.memberIDFromFilenameMeta","text":"memberIDFromFilenameMeta(fn_meta::FilenameMeta)\n\nReturn a string of the form modelname#memberID[_grid] that identifies the corresponding model member.\n\nFor CMIP6 models the abbreviation of the grid is added to the model name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.memberIDsFromPaths-Tuple{Vector{String}}","page":"Public API","title":"ModelWeights.Data.memberIDsFromPaths","text":"memberIDsFromPaths(all_paths::Vector{String})\n\nFor every path in all_paths return a string of the form modelname#memberID[grid] that identifies the corresponding model member. Filenames must follow the CMIP-standard (projnamemipexpidvariable[_grid].nc).\n\nFor CMIP6 models the abbreviation of the grid is added to the model name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.membersToModels-Tuple{AbstractArray{String}}","page":"Public API","title":"ModelWeights.Data.membersToModels","text":"membersToModels(members::AbstractArray{String})\n\nArguments:\n\nmembers::AbstractArray{String}: unique names of model members with model name followed by separator followed by unique identifiers.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.mergeMetaDataFromMultipleFiles-Tuple{AbstractVector{<:AbstractArray}}","page":"Public API","title":"ModelWeights.Data.mergeMetaDataFromMultipleFiles","text":"mergeMetaDataFromMultipleFiles(data::Vector{<:YAXArray})\n\nCombine arrays in data into a single YAXArray with meta combined from all datasets into  lists, with missing if key wasnt in a dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.metaDataChecksCMIP-Union{Tuple{T}, Tuple{Dict{String, T}, String}} where T","page":"Public API","title":"ModelWeights.Data.metaDataChecksCMIP","text":"metaDataChecksCMIP(meta::Dict, path::String)\n\nCheck model names as retrieved from the metadata for potential inconsistencies wrt filename.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.metaDataFromESMValToolRecipes-Tuple{String}","page":"Public API","title":"ModelWeights.Data.metaDataFromESMValToolRecipes","text":"metaDataFromESMValToolRecipes(\n    base_path_configs::String; constraint::Union{Dict, Nothing} = nothing\n)\n\nRead variable, statistic, experiment and timerange/alias values from ESMValTool recipes  stored at base_path_configs into a vector of Dictionaries storing the respective readoff  values.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.metaDataFromYAML-Tuple{Dict}","page":"Public API","title":"ModelWeights.Data.metaDataFromYAML","text":"metaDataFromYAML(ds::Dict)\n\nReturn metadata of data specified in ds.\n\nArguments:\n\nds: content of config yaml file specifying meta attributes and paths of data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.modelDim-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.modelDim","text":"modelDim(data::YAXArray)\n\nReturn the model dimension of data which must either be :model or :member.\n\nIf none is present, throw ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.modelDims-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.modelDims","text":"modelDims(data::YAXArray)\n\nReturn vector of dimensions of data that contain either 'model' or 'member'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.nbModelMembers-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.nbModelMembers","text":"nbModelMembers(data::YAXArray)\n\nReturn a dictionary mapping from models in data to the number of its members.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.normalizeDict-Tuple{Dict{String, <:Number}}","page":"Public API","title":"ModelWeights.Data.normalizeDict","text":"normalizeDict(data::Dict{String, <:Number})\n\nNormalize values for every entry in data such that they sum up to 1. If remove_zero is true (default), the returned dictionary does not contain entries for which values were 0.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.parseFilename-Tuple{String, String}","page":"Public API","title":"ModelWeights.Data.parseFilename","text":"parseFilename(filename::String, format::String)\n\nRetrieve information from filename and returns it as an object of type FilenameMeta.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.putAtModel!-Tuple{YAXArrays.Cubes.YAXArray, Symbol, String, Any}","page":"Public API","title":"ModelWeights.Data.putAtModel!","text":"putAtModel!(data::YAXArray, dimension::Symbol, model::String, input)\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.quantile-Tuple{AbstractArray{<:Number}, Number}","page":"Public API","title":"ModelWeights.Data.quantile","text":"quantile(samples::Vector{<:Number}, p::Number)\n\nCompute the p-th quantile.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.readDataFromDisk-Tuple{String}","page":"Public API","title":"ModelWeights.Data.readDataFromDisk","text":"readDataFromDisk(target_path::String; variable::String=\"\")\n\nLoad data from target_path. If target_path ends with '.jld2', variable  must be specified, otherwise  data is assumed to be binary.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.resolvePathsFromMetaData-Tuple{ModelWeights.Data.MetaData, String, Bool}","page":"Public API","title":"ModelWeights.Data.resolvePathsFromMetaData","text":"resolvePathsFromMetaData( \n    meta::MetaData,\n    base_path::String,\n    dir_per_var::Bool;\n    constraint::Union{Dict, Nothing} = nothing\n)\n\nReturn paths to data files for data specified in meta, possibly constraint by values in  constraint. The paths were the data is stored is expected to follow the following  structure (corresponding to the output from ESMValTool used for preprocessing the data):\n\nbase_path is the top-level directory. If dir_per_var is true, base_path is assumed to  have a (or several) subdirectory for each climate variable with VAR as part of the  subdirectory's name (e.g. _tas, cmip5tas, etc.). These subdirectories may be constraint by  containing at least one of the values in constraint[\"base_subdirs\"]. \n\nLet BASE refer to base_path, or respectively, to the subdirectories for the climate  variables. Then the following structure is: BASE/preproc/meta.alias/meta.subdir.  In ESMValTool, meta.alias corresponds to the (self-chosen) name under the section  'diagnostics' and meta.subdir to the (self-chosen) name under the section 'variables'.\n\nThe returned paths are the paths to all files within this directory, possibly constraint by  the filenames containig at least one string in constraint[\"projects\"] and respectively  at least one string in constraint[\"models\"]. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.setDim-Union{Tuple{T}, Tuple{YAXArrays.Cubes.YAXArray, Union{String, Symbol}, Union{Nothing, String, Symbol}, Union{Nothing, Vector{T}}}} where T<:Union{Number, String}","page":"Public API","title":"ModelWeights.Data.setDim","text":"setDim(\n    data::YAXArray, \n    dim::Union{String, Symbol},\n    dim_name::Union{Nothing, String, Symbol},\n    dim_vals::Union{Nothing, Vector{String}}\n)\n\nRename dimension dim to dim_name and/or its values to dim_vals. If dim_name or dim_vals is nothing, name/vals don't change.\n\nArguments:\n\ndata::YAXArray:\ndim::Union{String, Symbol}: Name of the dimension to be changed.\ndim_name::Union{Nothing, String, Symbol}: New dimension name.\ndim_vals::Union{Nothing, Vector{String}}:  New dimension values.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.setLookupsFromMemberToModel-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Public API","title":"ModelWeights.Data.setLookupsFromMemberToModel","text":"setLookupsFromMemberToModel(data::YAXArray, dim_names::Vector{String})\n\nChange the lookup values for the dimension 'member' to refer to the models, i.e. they are not unique anymore. This is done in preparation to group the data by the different models.\n\nArguments:\n\ndata::YAXArray: has at least dimensions in dim_names.\ndim_names::Vector{String}: names of dimensions to be changed, e.g. 'member', \n\n'member1' (would be changed to 'model', 'model1').\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.sharedLevelMembers-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Public API","title":"ModelWeights.Data.sharedLevelMembers","text":"sharedLevelMembers(data::DataMap)\n\nReturn vector of model members that are shared across all entries in data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.sharedLevelModels-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Public API","title":"ModelWeights.Data.sharedLevelModels","text":"sharedLevelModels(data::DataMap)\n\nReturn vector of models (on level of models, not members) that are shared across all entries in data.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.sharedModels-Tuple{Vector{Vector{String}}, ModelWeights.Data.Level, Union{String, Symbol}}","page":"Public API","title":"ModelWeights.Data.sharedModels","text":"sharedModels(\n    all_paths::Vector{Vector{String}},\n    level_shared::Level,\n    fn_format::Union{Symbol, String}\n)\n\nArguments:\n\nall_paths: every entry refers to the paths to data files for the respective dataset\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.sortLongitudesEast2West-Tuple{AbstractArray}","page":"Public API","title":"ModelWeights.Data.sortLongitudesEast2West","text":"sortLongitudesWest2East(data::AbstractArray)\n\nArrange 'data' such that western latitudes come first, then eastern latitudes.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.sortLongitudesWest2East-Tuple{AbstractArray}","page":"Public API","title":"ModelWeights.Data.sortLongitudesWest2East","text":"sortLongitudesWest2East(data::AbstractArray)\n\nArrange 'data' such that western latitudes come first, then eastern latitudes.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.subsetDataMap-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Vector{String}}","page":"Public API","title":"ModelWeights.Data.subsetDataMap","text":"subsetDataMap(data::DataMap, ids::Vector{String})\n\nReturn new DataMap with data from data at ids.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.subsetMeta!-Tuple{Dict, Vector{<:Int64}}","page":"Public API","title":"ModelWeights.Data.subsetMeta!","text":"subsetMeta(meta::Dict, indices::Vector{<:Int}; simplify::Bool = false)\n\nIf simplify is true, use single value when all remaining elements in a vector in meta are  identical, otherwise just keep vector.\n\nArguments:\n\nmeta:\nindices: indices to remain in vectors mapped to in meta. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.subsetMeta-Tuple{Dict, Vector{<:Int64}}","page":"Public API","title":"ModelWeights.Data.subsetMeta","text":"subsetMeta(meta::Dict, indices::Vector{<:Int}; simplify::Bool = false)\n\nIf simplify is true, use single value when all remaining elements in a vector in meta are  identical, otherwise just keep vector.\n\nArguments:\n\nmeta:\nindices: indices to remain in vectors mapped to in meta. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.subsetModelData","page":"Public API","title":"ModelWeights.Data.subsetModelData","text":"subsetModelData(dm::DataMap, level::Level=MEMBER_LEVEL; ids::Vector{String}=Vector{String}())\n\nFor those datasets in datamap that specify data on the level level (i.e. have dimension  :member or :model), return a new DataMap with subset of data s.t. the new datasets all have  the same models (MODELLEVEL) or members (MEMBERLEVEL).\n\nIf no models are shared across datasets, return the input datamap.\n\n\n\n\n\n","category":"function"},{"location":"reference/API/#ModelWeights.Data.subsetModelData-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Public API","title":"ModelWeights.Data.subsetModelData","text":"subsetModelData(data::YAXArray, shared_models::Vector{String})\n\nReturn subset of data containing only data from models in shared_models. \n\nTakes care of metadata.\n\nArguments:\n\ndata: must have a dimension that contains 'member' or 'model'\nshared_models: models, which can either be on level of models or members of models \n\n('modelname#memberID[_grid]').\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembers!-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Public API","title":"ModelWeights.Data.summarizeMembers!","text":"summarizeMembers!(data::DataMap; fn::Function=Statistics.mean)\n\nSet values for every dataset in data to the average across all members of  each model.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembers-Tuple{AbstractArray, Int64, AbstractArray{String}}","page":"Public API","title":"ModelWeights.Data.summarizeMembers","text":"summarizeMembers(\n    data::AbstractArray,\n    dim::Int,\n    members::AbstractArray{String}; \n    fn::Function=Statistics.mean\n)\n\nFor each model compute a summary statistic (default: mean) across all its members.  Return Array summarized in model dimension.\n\nArguments:\n\ndata::AbstractArray: must have dimension 'member' and at least one other arbitrary dimension \ndim::Int: index of member dimension\nmembers::AbstractArray{String}: names of members corresponding to member dimension in data.\nfn::Function: Function to be applied on data\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembers-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}}","page":"Public API","title":"ModelWeights.Data.summarizeMembers","text":"summarizeMembers(data::DataMap; fn::Function=Statistics.mean)\n\nReturn new DataMap containing every dataset in data summarized by applying fn  (default: mean) to all members of each model.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembers-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.summarizeMembers","text":"summarizeMembers(data::YAXArray; fn::Function=Statistics.mean)\n\nFor each model compute a summary statistic (default: mean) across all its members. \n\nThe returned YAXArray has dimension 'model'.\n\nArguments:\n\ndata::YAXArray: YAXArray; must have dimension 'member'\nupdateMeta::Bool: set true if the vectors in the metadata refer to \n\ndifferent models. Set to false if vectors refer to different variables.\n\nfn::Function: Function to be applied on data\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembersMatrix-Tuple{YAXArrays.Cubes.YAXArray, Bool}","page":"Public API","title":"ModelWeights.Data.summarizeMembersMatrix","text":"summarizeMembersMatrix(data::AbstractArray, updateMeta::Bool; fn::Function=Statistics.mean)\n\nCompute the average across all members of each model for each given variable  for model to model data, e.g. distances between model pairs.\n\nArguments:\n\ndata: with at least dimensions 'member1', 'member2'\nupdateMeta: set true if the vectors in the metadata refer to different models. \n\nSet to false if vectors refer to different variables for instance. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.summarizeMembersVector-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Data.summarizeMembersVector","text":"summarizeMembersVector(data::YAXArray; fn::Function=Statistics.mean)\n\nFor each model compute a summary statistic (default: mean) across all its members.  The returned YAXArray has dimension :model (instead of :member).\n\nArguments:\n\ndata::YAXArray: YAXArray; must have dimension 'member' and at least one other arbitrary dimension \nfn::Function: Function to be applied on data\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.throwErrorIfDimMissing-Tuple{YAXArrays.Cubes.YAXArray, Symbol}","page":"Public API","title":"ModelWeights.Data.throwErrorIfDimMissing","text":"throwErrorIfDimMissing(data::YAXArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.throwErrorIfDimMissing-Tuple{YAXArrays.Cubes.YAXArray, Vector{Symbol}}","page":"Public API","title":"ModelWeights.Data.throwErrorIfDimMissing","text":"throwErrorIfDimMissing(data::YAXArray, dimensions::Vector{Symbol}; include::Symbol=:all)\n\nThrow ArgumentError if data does not have ALL dimensions in dimensions when  include=:all (default), or if data does not have ANY dimension in dimensions.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.uncertaintyRanges-Tuple{AbstractArray}","page":"Public API","title":"ModelWeights.Data.uncertaintyRanges","text":"uncertaintyRanges(\n    data::AbstractArray; w::Union{DimArray, Nothing}=nothing, quantiles=[0.167, 0.833]\n)\n\nCompute weighted quantiles of timeseries data.\n\nArguments:\n\ndata::AbstractArray: must have dimensions 'time', 'model'.\nw::Union{DimArray, Nothing}=nothing: must have dimensions 'model' and 'weight', each \n\n'weight'-vector must sum up to 1.\n\nquantiles=[0.167, 0.833]: vector with two entries between 0 and 1 representing  the \n\nlower and upper bound in this order.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.updateGroupedDataMetadata-Tuple{Dict, DimensionalData.DimGroupByArray}","page":"Public API","title":"ModelWeights.Data.updateGroupedDataMetadata","text":"updateGroupedDataMetadata(meta::Dict, grouped_data::DimensionalData.DimGroupByArray)\n\nSummarize vectors in meta, refering to different models (members), such that  each vector only contains N entries (N=number of models (i.e. without unique members)).\n\nIf the metadata for members of a model differ across members, the respective entry in the vector will be a vector itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Data.writeDataToDisk-Tuple{Any, String}","page":"Public API","title":"ModelWeights.Data.writeDataToDisk","text":"writeDataToDisk(data, target_path::String)\n\nSave data as Julia obj if target_path has ending '.jld2', otherwise save as binary. If file at target_path already exists, timestamp is added if overwrite is false (default).\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.convertKgsToSv!-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Plots.convertKgsToSv!","text":"convertKgsToSv!(vec:YAXArray)\n\nConvert data given in unit 'kg s-1' into Sverdrups (Sv).\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.getClosestGridPoint-Tuple{Dict, Vector, Vector}","page":"Public API","title":"ModelWeights.Plots.getClosestGridPoint","text":"getClosestGridPoint(location::Dict, longitudes::Vector, latitudes::Vector)\n\nFind the grid point in grid defined by longitudes and latitudes that is closest to location.\n\nArguments\n\nlocation::Dict: 'lon', 'lat' of position for which closest grid point is\n\nreturned, lon must be given from -180° to 180°\n\nlongitudes::Vector: grid longitudes measured from -180° to 180°\nlatitudes::Vector: grid latitudes measured from -90° to 90°\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.latitude2NorthSouth-Tuple{Number}","page":"Public API","title":"ModelWeights.Plots.latitude2NorthSouth","text":"latitude2NorthSouth(lat::Number)\n\nConvert latitudes from -90° to 90° into 0° to 90° North/South.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.longitude2EastWest-Tuple{Number}","page":"Public API","title":"ModelWeights.Plots.longitude2EastWest","text":"longitude2EastWest(lon::Number)\n\nConvert longitudes from -180° to 180° into 0° to 180° East/West.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.makeSubplots-Tuple{AbstractArray, @NamedTuple{nrows::Int64, ncols::Int64}}","page":"Public API","title":"ModelWeights.Plots.makeSubplots","text":"makeSubplots\n\nArguments:\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotAMOC-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Plots.plotAMOC","text":"plotAMOC(data::DimArray)\n\nPlot AMOC strength for variable \"amoc\".\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotDistances-Tuple{AbstractArray, String}","page":"Public API","title":"ModelWeights.Plots.plotDistances","text":"plotDistances(dists::AbstractArray, title::String; is_bar_plot::Bool=true)\n\nPlot figure of distances.\n\nArguments:\n\ndists::AbstractArray:\ntitle::String:\nis_bar_plot::Bool = true:\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotDistancesIndependence-Tuple{AbstractArray, String}","page":"Public API","title":"ModelWeights.Plots.plotDistancesIndependence","text":"plotDistancesIndependence(\n    distances::AbstractArray, dimname::String; title::String=\"Generalized distances Sij\"\n)\n\nArguments:\n\ndistances::AbstractArray:\ndimname::String:\ntitle::String:\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotEnsembleSpread-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Plots.plotEnsembleSpread","text":"plotEnsembleSpread(\n    data::YAXArray; fn::Function=Statistics.median, title::String=\"\", ylabel::String=\"\"\n)\n\nPlot models against values of all model members. Add summary statistics (default: median)  when computed across all model members and when average values across members of each model  are computed first.\n\nArguments:\n\ndata::YAXArray: must have single dimension :member.\nfn::Function=Statistics.median: function to summarize data.\ntitle::String: (optional) plot title.\nylabel::String: (optional) label for y-axis.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotHistAtPos-Tuple{YAXArrays.Cubes.YAXArray, Dict}","page":"Public API","title":"ModelWeights.Plots.plotHistAtPos","text":"plotHistAtPos(data::AbstractArray, location::Dict)\n\nPlot histogram of all data for a specific location.\n\nArguments:\n\ndata: dimensions 'lon' (from -180° to 180°), 'lat' (-90° to 90°)\nlocation: must have keys 'name', 'lon', 'lat'\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotTempGraph-Tuple{YAXArrays.Cubes.YAXArray, NamedTuple, NamedTuple, String}","page":"Public API","title":"ModelWeights.Plots.plotTempGraph","text":"plotTempGraph\n\n# TODO: change quantileLabels and uncertainty_ranges, the latter should contain \n# the quantile labels\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotTimeseries!-Tuple{Makie.Axis, AbstractArray}","page":"Public API","title":"ModelWeights.Plots.plotTimeseries!","text":"plotTimeseries!(ax::Axis, vals::AbstractArray;)\n\nPlot timeseries of data vector vals.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotValsOnMap!-Tuple{Makie.Figure, AbstractArray, String}","page":"Public API","title":"ModelWeights.Plots.plotValsOnMap!","text":"plotValsOnMap!(fig::Figure, means::AbstractArray, title::String;                     colors=nothing, colorrange=nothing, highclip=(1,0,0),                     lowclip=(0,0,1), pos=(x=1, y=1), poslegend=nothing                     )\n\nPlot contours of world with an overlayed heatmap of the input data.\n\nArguments:\n\npos::NamedTuple(x::Int,y::Int): position of plot in fig\ncolor_range::Union{Nothing, Tuple}: Real values, outside this range, a single color is used.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Plots.plotWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Plots.plotWeights","text":"plotWeights(weights::YAXArray; title::String=\"\", sort_by::String=\"\")\n\nPlot weights sorted by weight dimension sort_by of weights if given, otherwise, sorted by first value in weight dimension.\n\nEqual weights line is added to the plot.\n\nArguments:\n\nweights::YAXArray: with dimensions :weight and :model\ntitle::String:\nsort_by::String: value of weight dimension according to which data is sorted\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Timeseries.computeLinearTrend-Tuple{Vector, Vector}","page":"Public API","title":"ModelWeights.Timeseries.computeLinearTrend","text":"computeLinearTrend(x::Vector, y::Vector; full_predictions::Bool = false)\n\nRegress y on x and return slope (default) or predicted y for every element in x (if full_predictions=true)\n\nArguments:\n\nx::Vector:\ny:Vector:\nfull_predictions::Bool: if false, return slope, otherwise return all values predicted for x.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Timeseries.filterTimeseries-Tuple{YAXArrays.Cubes.YAXArray, Number, Number}","page":"Public API","title":"ModelWeights.Timeseries.filterTimeseries","text":"function filterTimeseries(\n    data::YAXArray,\n    start_year::Number,\n    end_year::Number;\n    only_models_non_missing_vals::Bool = true\n)\n\nArguments:\n\ndata::YAXArray:\nstart_year::Number: set to -Inf to not filter for start time.\nend_year::Number: set to Inf to not filter for end time.\nonly_models_non_missing_vals::Bool = true:\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Timeseries.linearTrend-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Timeseries.linearTrend","text":"linearTrend(data::YAXArray; full_predictions::Bool=true)\n\nCompute linear trend as ordinary least squares for timeseries data and return slope  (default) or predicted y for every element in x (if full_predictions=true)\n\nArguments:\n\ndata::YAXArray: must have dimension :time.\nfull_predictions::Bool:\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.applyWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.applyWeights","text":"applyWeights(model_data::YAXArray, weights::YAXArray)\n\nCompute the weighted average of model data data with given weights.\n\nIf weights were computed for a superset of the models in data, they are normalized and applied to the subset. Only weights per model (not members) are considered for now, in the future, members should be considered too.\n\nArguments:\n\nmodel_data::YAXArray: model predictions. If given for model members, the predictions \n\nof each model are considered the average value of all members of the respective model.\n\nweights::YAXArray: if given for each member of a model, these will be summed up to \n\nyield one value per model.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.climwipWeights-Tuple{Dict{String, YAXArrays.Cubes.YAXArray}, Dict{String, YAXArrays.Cubes.YAXArray}, ModelWeights.Weights.ConfigWeights}","page":"Public API","title":"ModelWeights.Weights.climwipWeights","text":"climwipWeights(\n    model_data::DataMap,\n    obs_data::DataMap,\n    config::ConfigWeights;\n    suffix_name::String = \"historical\"\n)\n\nCompute ClimwipWeights based on RMSE distances between observational data and model-model pairs.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.climwipWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, ModelWeights.Weights.ConfigWeights}","page":"Public API","title":"ModelWeights.Weights.climwipWeights","text":"climwipWeights(\n    dists_indep_all::YAXArray, \n    dists_perform_all::YAXArray,\n    config::ConfigWeights;\n    suffix_name::Stirng = \"climwip\"\n)\n\nCompute weight for each model in multi-model ensemble according to approach from Brunner, Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020. \n\nArguments:\n\ndists_indep_all::YAXArray: RMSEs between pairs of models for all \n\ncombinations of variables and diagnostics; has dimensions 'member1', 'member2', 'variable',  'diagnostic'.\n\ndists_perform_all::YAXArray: RMSEs between model and observational data for all \n\ncombinations of variables and diagnostics; has dimensions 'member', 'variable', 'diagnostic'.\n\nconfig::ConfigWeights: Parameters specifiying the relative contributions of each \n\ncombination of variable and diagnostic.\n\nsuffix_name::String: added to name of each type of weights, s.t. names are: wP-suffix, \n\nwI-suffix, combined-suffix (default 'climwip').\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.computeWeights-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.computeWeights","text":"computeWeights(lls::YAXArray, w_diagnostics::YAXArray)\n\nArguments:\n\nlls::YAXArray: log likelihoods, must have dimensions 'model', 'diagnostic'\ndiagnostic::YAXArray: must have dimension 'diagnostic' with the same values as in lls\nadjust_w::Bool If true (default), w_diagnostics is normalized to sum to 1 and scaled by \n\nthe number of diagnostics, otherwise w_diagnostics is not changed at all.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.computeWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.computeWeights","text":"computeWeights(lls::YAXArray)\n\nArguments:\n\nlls::YAXArray: log likelihoods, must have dimension 'model' and possibly 'diagnostic' as \n\nsecond dimension. If severl diangostics, equal weights for each are used (lls just summed up).\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.crps-Tuple{AbstractVector{<:Union{Missing, Number}}, Number}","page":"Public API","title":"ModelWeights.Weights.crps","text":"crps(samples::AbstractVector{<:Union{Missing, Number}}, obs::Number)\n\nReturn Continuous Ranked Probability Score (CRPS) for predicted samples and observation obs.\n\nQuantifies how good the forecast samples are a prediction for the given observation. Use closed Form definition of CRPS.\n\nArguments:\n\nsamples::AbstractVector{<:Union{Missing, Number}}: vector of predictions.\nobs::Number:: single observation.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.crps-Tuple{YAXArrays.Cubes.YAXArray{var\"#s645\", N, A} where {var\"#s645\"<:Union{Missing, Number}, N, A<:AbstractArray{var\"#s645\", N}}, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.crps","text":"crps(samples::YAXArray{<:Union{Missing, Number}}, obs::YAXArray)\n\nCompute Continuous Ranked Probability Score (CRPS) for predicted samples and observation obs.\n\nArguments:\n\nsamples: must have at least one more dimension than :model or :member (e.g. model x lon x lat)\nobs: must have the same dimensions as samples except for the model dimension (:model or :member)\n\nwhich is only present in samples.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.crpss-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.crpss","text":"crpss(samplesforecast::YAXArray, samplesbaseline::YAXArray, observations::YAXArray})\n\nCompute Continuous Ranked Probability Skill Score for forecast with respect to baseline. \n\nFor every timestep there are predicted samples of the forecast (samples_forecast) and of the baseline samples_baseline (respectively one per model in the ensemble) and for every  timestep there is exactly one observation. The CRPSS is based on the average CRPS across timesteps.\n\nArguments:\n\nsamples_forecast::YAXArray: must have dimension :time and :model or :member\nsamples_baseline::YAXArray: must have dimension :time and :model or :member\nobservations::YAXArray: must have only dimension :time\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.crpss_weighted-Tuple{YAXArrays.Cubes.YAXArray, Number, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.crpss_weighted","text":"crpss_weighted(samples::YAXArray, observed::Number, weights::YAXArray)\n\nCompute Continuous Ranked Probability Skill Score for weighted vs. unweighted predictions.\n\nsamples is one prediction per model in the ensemble, observed is the observed value.\n\nArguments:\n\nsamples::YAXArray: must have dimension :model or :member\nobserved::Number:\nweights::YAXArray: must have same model dimension as samples (:model or :member)\nn::Int=1000: length sample vector for computing weighted samples\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.crpss_weighted-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.crpss_weighted","text":"crpss_weighted(samples::YAXArray, observations::YAXArray, weights::YAXArray; n::Int=1000)\n\nCompute Continuous Ranked Probability Skill Score for weighted vs. unweighted predictions for timeseries.\n\nFor every timestep there are predicted samples, one per model in the ensemble and for  every timestep there is exactly one observation. The CRPSS is based on the average CRPS across timesteps.\n\nArguments:\n\nsamples::YAXArray: must have dimension :time and :model or :member\nobservations::YAXArray: must have only dimension :time\nweights::YAXArray: must have same model dimension as samples (:model or :member)\nn::Int=1000: length sample vector for computing weighted samples\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.distributeWeightsAcrossMembers-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}}","page":"Public API","title":"ModelWeights.Weights.distributeWeightsAcrossMembers","text":"distributeWeightsAcrossMembers(weights::YAXArray, members::Vector{String})\n\nEqually distribute weight for each model over its members.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.equalWeights-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.equalWeights","text":"equalWeights(data::YAXArray; use_members::Bool=true)\n\nCreate a weight vector, with equal weight for each MODEL. Distribute weight across model members if dimension=:member and usemembers is true. If usemember is false,  each model member is considered as standalone model and all receive the same weight.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.independenceWeights-Tuple{YAXArrays.Cubes.YAXArray, Number}","page":"Public API","title":"ModelWeights.Weights.independenceWeights","text":"independenceWeights(Sij::YAXArray, sigmaS::Number)\n\nCompute the independence weight for each model i with generalized distances between pairs of models, Sij.\n\nw^I_i = a_0 cdot frac11 + sum_j ne i e^-left( fracS_ijsigma_S right)^2\n\nArguments:\n\nSij: generalized distances for each pair of models with dimensions 'model1', 'model2'\nsigmaS: free shape parameter for impact of independence weights\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.llInverseMSE-Tuple{AbstractArray, AbstractArray, AbstractArray{String}, AbstractArray{<:Real}, Int64, Bool, Int64, AbstractArray}","page":"Public API","title":"ModelWeights.Weights.llInverseMSE","text":"llInverseMSE(\n    data::AbstractArray, \n    obs::AbstractArray,\n    model_names::AbstractArray{String}, # if summarize_members is true these refer to members\n    latitudes::AbstractArray{<:Real},\n    model_dim::Int,\n    summarize_members::Bool,\n    diagnostic_dim::Int;\n    best_model::Union{AbstractArray, Nothing}=nothing\n)\n\nCompute log likelihood for every diagnostic in data. Return an Array with dimensions 'model' and 'diagnostic' if data has dimension 'diagnostic'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.llInverseMSE-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.llInverseMSE","text":"llInverseMSE(data::YAXArray, obs::YAXArray)\n\nCompute log likelihood for every diagnostic in data. Return a YAXArray with dimensions 'model' and 'diagnostic' if data has dimension 'diagnostic'.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.performanceWeights-Tuple{YAXArrays.Cubes.YAXArray, Number}","page":"Public API","title":"ModelWeights.Weights.performanceWeights","text":"performanceWeights(Di::AbstractArray, sigmaD::Number)\n\nCompute the ClimWIP performance weight for each model i with generalized distances Di.\n\nw^P_i = a_0 cdot frace^-(fracD_isigma_D)^2N\n\nArguments:\n\nDi::YAXArray: generalized distances Di for each model\nsigmaD::Number: free shape parameter for impact of performance weights\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.rps-Tuple{Vector{<:Number}, Int64}","page":"Public API","title":"ModelWeights.Weights.rps","text":"rps(p_hat::Vector{<:Number}, cat::Int)\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.saveWeightsAsNCFile-Tuple{ModelWeights.Weights.ClimWIP, String}","page":"Public API","title":"ModelWeights.Weights.saveWeightsAsNCFile","text":"saveWeightsAsNCFile(weights::ClimWIP; target_path::String)\n\nTODO: needs to be updated, deprecated\n\nArguments:\n\nweights: ClimWIP object to be saved.\ntarget_path: Path to where weights shall be stored.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.weightSamples-Tuple{YAXArrays.Cubes.YAXArray, YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.weightSamples","text":"weightSamples(samples::YAXArray, weights::YAXArray; n::Int = 1000)\n\nRepeat each entry in samples proportional to respective value given in weights so that  the returned vector has n entries.\n\nArguments:\n\nsamples::YAXArray: must have dimension :model or :member.\nweights::YAXArray: must have same model dimension as samples (:model or :member).\nn::Int = 1000: length of returned vector. \n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.weightedAvg-Tuple{YAXArrays.Cubes.YAXArray}","page":"Public API","title":"ModelWeights.Weights.weightedAvg","text":"weightedAvg(\n    data::YAXArray; \n    weights::Union{YAXArray, Nothing} = nothing, \n    use_members_equal_weights::Bool = true\n)\n\nCompute the average values for each (lon,lat) grid point in data, weighted by weights. \n\nIf no weight vector is provided, unweighted average is computed.\n\nArguments:\n\ndata::YAXArray: must have dimension 'model' or 'member'\nweights::Union{YAXArray, Nothing} = nothing: weights for models or individual members\nuse_members_equal_weights::Bool:  if weights is nothing, all models receive \n\nequal weight. Then, if use_members_equal_weights is true, the number of members  per model is taken into account, e.g. [\"m1#run1\", \"m1#run2\", \"m1#run3\", \"m2#run1\"] yields  [1/4, 1/4, 1/4, 1/4] if use_members_equal_weights = false and if  use_members_equal_weights = true, [1/2 * 1/3, 1/2 * 1/3, 1/2 * 3, 1/2] = [1/6, 1/6, 1/6, 1/2].\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#ModelWeights.Weights.MMEWeights-Tuple{YAXArrays.Cubes.YAXArray, Vector{String}, String}","page":"Public API","title":"ModelWeights.Weights.MMEWeights","text":"MMEWeights(weights::YAXArray, ids::Vector{String}, name::String)\n\nCombine weights given in weights at ids into a normalized MMEWeight.\n\nArguments:\n\nweights::YAXArray: Must have dimensions :weight and :model.\nids::Vector{String}: weights in weights where dimension :weights equals these ids will be combined.\nname::String: Name of the new MMEWeights-instance.\n\n\n\n\n\n","category":"method"},{"location":"examples/lgm/#Weights-for-models-of-lgm-experiment","page":"Weights for models of lgm experiment","title":"Weights for models of lgm experiment","text":"First, we want to load all CMIP5 and CMIP6 model data for the lgm-experiment.\n\n# points to directory where preprocessed data is stored\npath_data = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/LGM\";\n# point to directory where config files are stored\npath_recipes = \"/albedo/home/brgrus001/SimilarityWeights/configs/lgm-cmip5-cmip6\";\n\nlgm_data = mw.loadDataFromESMValToolConfigs(\n    path_data, path_recipes;\n    dir_per_var = true, # default: true\n    is_model_data = true, # default: true \n    only_shared_models = true, # default: false\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"lgm\"],\n        projects = [\"CMIP5\", \"CMIP6\"],\n        models = Vector{String}(),\n        subdirs = [\"20241114\"]\n    ),\n    preview = false # default value is false\n);\nmodel_members_lgm = Array(dims(first(values(lgm_data)), :member))\n\nThen, we load data from the same models for the historical experiment:\n\nbase_path = \"/albedo/work/projects/p_forclima/preproc_data_esmvaltool/historical/\";\nconfig_path = \"/albedo/home/brgrus001/SimilarityWeights/configs/historical\";\nhistorical_data = mw.loadDataFromESMValToolConfigs(\n    base_path, config_path;\n    only_shared_models = true,\n    subset = mw.Constraint(\n        statistics = [\"CLIM\"],\n        variables = [\"tas\", \"tos\"],\n        aliases = [\"historical\"],\n        timeranges = [\"full\"],\n        models = model_members_lgm,\n        subdirs = [\"20241121\", \"20241118\"]\n    )\n);\n````\n\nThis is the resulting data:\n\njulia\n\n\nWe could also have used a single yaml configuration file independent of the ESMValTool recipes and load the data all together one:\n\n\n\njulia","category":"section"},{"location":"examples/lgm/#Load-model-data-for-experiment-lgm-and-historical-in-one-run-from-new-config-file","page":"Weights for models of lgm experiment","title":"Load model data for experiment lgm and historical in one run from new config file","text":"pathconfig = \"/albedo/work/projects/pforclima/preprocdataesmvaltool/configs-SimilarityWeights/example-lgm-historical.yml\";\n\nmodeldata = mw.loadDataFromYAML(     pathconfig;     dirpervar = true, # default: true     ismodeldata = true, # default: true     onlysharedmodels = true, # default: false     preview = false ); ```","category":"section"},{"location":"examples/lgm/#TODO:-show-that-we-get-the-same-outfit-different-approaches!","page":"Weights for models of lgm experiment","title":"TODO: show that we get the same outfit different approaches!","text":"","category":"section"},{"location":"reference/references/#References","page":"References","title":"References","text":"Brunner Lukas, Angeline G. Pendergrass, Flavio Lehner, Anna L. Merrifield, Ruth Lorenz, and Reto Knutti. “Reduced Global Warming from CMIP6 Projections When Weighting Models by Performance and Independence.” Earth System Dynamics 11, no. 4 (November 13, 2020): 995–1012. https://doi.org/10.5194/esd-11-995-2020.\nKnutti, Reto, Jan Sedláček, Benjamin M. Sanderson, Ruth Lorenz, Erich M. Fischer, and Veronika Eyring. “A Climate Model Projection Weighting Scheme Accounting for Performance and Interdependence.” Geophysical Research Letters 44, no. 4 (2017): 4. https://doi.org/10.1002/2016GL072012.\nSanderson, Benjamin M., Reto Knutti, and Peter Caldwell. “Addressing Interdependency in a Multimodel Ensemble by Interpolation of Model Properties in: Journal of Climate Volume 28 Issue 13 (2015).” Journal of Climate 28, no. 13 (2015): 5150–70.\nSanderson, Benjamin M., Reto Knutti, and Peter Caldwell. “A Representative Democracy to Reduce Interdependency in a Multimodel Ensemble.” Journal of Climate. Journal of Climate 28, no. 13 (2015): 5171–94. https://doi.org/10.1175/JCLI-D-14-00362.1.\n\nThe package logo was created with ChatGPT.","category":"section"},{"location":"#ModelWeights.jl","page":"Home","title":"ModelWeights.jl","text":"A package to compute weights (based on independence- and performance) for ensembles of Earth System Models (ESMs), especially CMIP models, including convenience functions for handling climate model data.\n\nTo use the provided functionalities the data must be available on the same grid.","category":"section"},{"location":"#Package-features","page":"Home","title":"Package features","text":"load data for different variables/experiments into convenient data format\nfilter data to get only models with specific variables for various experiments\ncompute independence weights based on model similarity\ncompute performance weights based on historical period or based on custom function\ncombine independence- and performance weights","category":"section"},{"location":"#Content","page":"Home","title":"Content","text":"","category":"section"},{"location":"Manual/filtering-data/#Filtering-data","page":"Filtering data","title":"Filtering data","text":"When loading data with the function defineDataMap, there is the option to filter the data in several ways, using the the optional keyword argument constraint. Note that the filtering is done based on the information retrieved from the filenames. That is, the provided values must correspond to how the data is stored. For CMIP6 data, variables must, for instance, point to the variables' id, e.g. 'tas', 'psl', etc. \n\nThe following keys are considered for the dictionary constraint. If not stated otherwise, they map to a vector.\n\nexperiments: load only data from given experiments, e.g. [\"lgm\", \"historical\"]\nfilenames:  load only data from any of the given files\ngrids: load only data with given grids, e.g. [\"gn\"]\nmips: load only data from given projects, e.g. to load only CMIP5 data, set to [\"CMIP5\"]\nmodels: load only data from given models. It is possible to include (1) general models (e.g., \"ACCESS-CM2\"), which would load all available simulations of the respective model or (2) specific model simulations. The latter are specified as the MODELNAME#VARIANT, e.g., \"ACCESS-CM2#r1i1p1f1\".  \ntable_ids: load only data from given tables, e.g. [\"Amon\", \"Omon\"]\nvariables: if provided, only data for given variables is loaded, otherwise all data in the specified directories is loaded.\nvariants: load only specific runs, e.g. [\"r1i1p1f1\", ...]\ntimeranges: load only data from files for given timeranges, e.g. [\"185001-1850012\", \"195001-195012\"]\nlevel_shared::Union{String, Symbol}: one of: \"member\", \"model\", :member, :model. The function that is called to constrain the loaded data by the models/members shared across all datasets is subsetModelData. For more details see next paragraph. ","category":"section"},{"location":"Manual/filtering-data/#level_shared:-Datasets-that-share-the-same-members/models","page":"Filtering data","title":"level_shared: Datasets that share the same members/models","text":"This is the most important constraint. It allows to filter the data such that every loaded dataset contains only data from the same models or, more restricted, the same model variants/simulations. If set to \"member\" (or :member), data is only loaded if the respective \\emph{model simulation} is present for all specified datasets, i.e. for every variable and experiment. If it is set to \"model\" (or :model), data is only loaded from models that provide data for all specified datasets, yet independent of the exact simulations. That is, every loaded dataset may have of a different number of simulations for each model.","category":"section"},{"location":"Manual/filtering-data/#Further-filtering-options-for-data-preprocessed-with-ESMValTool","page":"Filtering data","title":"Further filtering options for data preprocessed with ESMValTool","text":"Besides the possibility to specify the paths to the data directories directly, there are two more ways to load data that was preprocessed with ESMValTool, using the function defineDataMap:\n\ndefineDataMap(path_data, path_recipes, source; dir_per_var::Bool=true): The first argument points to the top-level directory that contains the data, the second argument points to a directory that contains one or more ESMValTool recipes and source must be set to :esmvaltool_recipes. See loading data section based on recipes  for more information.\n\nThe additional keyword argument dir_per_var specifies whether there was one recipe per variable. If that's the case, there is a single directory for every variable and thus, to load data for a specific variable only subdirectories of the directory that path_data points to that contain the respective variable, more precisely _VARIABLE (e.g. _tas), in their name will be considered.\n\ndefineDataMap(yaml_content::Dict) and defineDataMap(path_config::String): Here, the only positional argument is either a dictionary with the configuration or a path to a yaml file with the respective configurations. See loading data section based on config files for more information.\n\nIn both cases, it is possible to constrain the directories from where data is loaded by specifying base_subdirs in the dictionary input argument constraint:\n\n\"base_subdirs\"::Vector{String}: If specified and if there is a single directory for every variable (default: true), only data is loaded from subdirectories of the given data path (base_path_data + base_dir when loading from yaml file) that contain any of the given strings in their name.\n\nTODO: following must be updated\n\nsubset\nvariables: The short name of the climate variable, e.g. [\"tas\", \"tos\"].\nstatistics: The statistic/diagnostic that was used when preprocessing the data. The names are generally arbitrary, but need to be identical to those you used in the recipe for preprocessing the data; for instance, we refer to the climatological average as \"CLIM\", s.t. an example value for this argument is [\"CLIM\"].\naliases: Like for statistics, the names are arbitrary but must be identical to the name you used in the recipe for preprocessing the data; an alias may, for instance, refer to a certain timerange of a certain experiment, e.g. \"historical-1950-1980\".\ntimeranges: Timeranges to be loaded; especially for historical data, you may preprocess data for different timeranges,  e.g. [\"full\", \"1980-2014\"]. \n\nNote that when using the option to load data preprocessed with ESMValTool from a seperate yaml file, in which it's possible to specify filtering options for each datasets, these values will be overwritten, if the same key is provided in the function argument, too. That is, the function argument takes precedence over what had been specified in the yaml file if a key is specified in both. If a key is just given in the yaml file, it will still be applied in the filtering.","category":"section"},{"location":"Manual/loading-data/#Loading-data","page":"Loading data","title":"Loading data","text":"The basic representation of data is in form of a dictionary that simply maps from ids  (Strings) to the data itself stored as YAXArrays. We name this type alias a DataMap. ","category":"section"},{"location":"Manual/loading-data/#Load-several-datasets-into-a-DataMap","page":"Loading data","title":"Load several datasets into a DataMap","text":"Data is loaded with the function defineDataMap. It defines several methods that we explain further below. \n\nThe defineDataMap methods provide a set of default keyword arguments: \n\npreview::Bool = false: set to true if instead of loading the data, a list of paths to the data that would be loaded with the given paths and constraints, is returned.\nsorted::Bool = true: set to false, if the loaded data should not be sorted alphabetically according to the model dimension.\n\nThe most important two arguments are filename_format and dtype which we will explain in turn next:","category":"section"},{"location":"Manual/loading-data/#Filename-format","page":"Loading data","title":"Filename format","text":"filename_format::Union{Symbol, String}: This argument is important since the data is loaded based on the information retrieved from the filenames of the data.\n\nThere are three predefined filename formats:\n\nVARIABLE_TABLEID_MODEL_EXPERIMENT_VARIANT_GRID_TIMERANGE (:cmip), default value\nMIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE (:esmvaltool_cmip5)\nMIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE_GRID (:esmvaltool_cmip6)\n\nIt is also possible to use the format :esmvaltool so that for every file it is automatically derived based on the fileformat whether it corresponds to CMIP5 or CMIP6.\n\nFurther, it is possible to specify your own filename format. TODO","category":"section"},{"location":"Manual/loading-data/#Data-Type-(dtype)","page":"Loading data","title":"Data Type (dtype)","text":"dtype::String = \"cmip\"\n\nFor now, the keyword argument dtype is just used to provide specific meta data when dtype=\"cmip\". This argument should be specified when not working with CMIP data (including observational data), since cmip is the default value.","category":"section"},{"location":"Manual/loading-data/#Metadata","page":"Loading data","title":"Metadata","text":"The metadata of each dataset (the .properties Dictionary of each YAXArray in a DataMap) contains the metadata loaded from the original files as well as additional information if it is provided in the optional keyword argument meta_data of function defineDataMap (a dictionary with keys of type String).","category":"section"},{"location":"Manual/loading-data/#Loading-data-from-directories","page":"Loading data","title":"Loading data from directories","text":"The datasets loaded in a DataMap all refer to a single variable and experiment, i.e. the  YAXArrays have the dimensions of the grid the data is defined on, e.g., (lon, lat) or,  for 3D data, (lon, lat, depth).\n\nTo load data for different datasets, e.g. variable tos for lgm and historical experiment:\n\nusing ModelWeights\npaths_datasets = [\"path/to/lgm/tos\", \"path/to/historical/tos\"]\nids_datasets = [\"lgm-tos\", \"historical-tos\"]\ndefineDataMap(paths_datasets, ids_datasets; dtype = \"cmip\")\n\nYou might have several directories from where you want to load data for a single dataset, e.g. when you store CMIP5 and CMIP6 data at different locations. defineDataMap also accepts Vectors of Vectors, e.g.:\n\npaths_datasets = [\n    [\"path/to/cmip5/lgm/tos\", \"path/to/cmip6/lgm/tos\"], \n    [\"path/to/cmip5/historical/tos\", \"path/to/cmip6/historical/tos\"]\n]\nids_datasets = [\"lgm-tos\", \"historical-tos\"]\ndefineDataMap(paths_datasets, ids_datasets; dtype = \"cmip\")\n\nIf you just want to load a single dataset, Vectors aren't needed, e.g.:\n\ndefineDataMap(\"path/to/lgm/tos\", \"lgm-tos\"; dtype = \"cmip\")","category":"section"},{"location":"Manual/loading-data/#Loading-data-preprocessed-with-ESMValTool","page":"Loading data","title":"Loading data preprocessed with ESMValTool","text":"","category":"section"},{"location":"Manual/loading-data/#loading-data-recipes","page":"Loading data","title":"Based on recipes","text":"If you use ESMValTool to preprocess data, you can use the recipes for preprocessing the data as config files to load the or some of the data into a ModelWeights.DataMap. The first argument points to the top-level directory where the data is stored, namely the same that was used in ESMValTool as base data directory. The second argument points to a directory that contains one or more recipes, namely the filled out versions of the recipes that are generated by ESMValTool, to be found in the run-directory. These have the same name as the recipe itself concatenated with _filled in the end.\n\nTo ensure that the first two arguments are correctly interpreted, the third argument must be set to :esmvaltool_recipes. In this case, the default value for filename_format is set to :esmvaltool (instead of :cmip). \n\ndefineDataMap(\"path/to/base/data/dir\", \"path/to/recipes/dir\", :esmvaltool_recipes; dtype = \"cmip\")","category":"section"},{"location":"Manual/loading-data/#loading-data-config","page":"Loading data","title":"Based on config files","text":"If the data was preprocessed with ESMValTool, it is also possible to specify a config yaml file with the required values. Here is an example that loads tas and tos data for the experiments lgm, historical and piControl: \n\nbase_path_data: \"/path/to/dir/with/preprocessed/data\"\n\ndatasets: [\n  {\n    base_dir: \"LGM\", \n    exp: \"lgm\", \n    variables: [\"tas\", \"tos\"],\n    aliases: [\"lgm\"],\n    statistics: [\"CLIM\"], \n    subset: {\n      base_subdirs: [\"20241114\"]\n    }\n  },\n  {\n    base_dir: \"piControl\", \n    exp: \"piControl\", \n    variables: [\"tas\", \"tos\"],\n    aliases: [\"piControl\"],  \n    statistics: [\"CLIM\"],\n    subset: {\n      base_subdirs: [\"lgm_models\", \"20250322\"]\n    }\n  },\n    {\n    base_dir: \"historical\", \n    exp: \"historical\", \n    variables: [\"tas\", \"tos\"],\n    aliases: [\"historical\"], \n    statistics: [\"CLIM\"]\n  }\n]\n\nTODO: update the following expected keys\n\nKeys expected in the config-yaml file:\n\npath_data: base path to where the preprocessed data is stored. This path will be concatenated with the directories specified for each dataset. It can \n\nbe omitted if inside datasets (see below), base_dir refers to the entire absolute path.\n\ndatasets: list of each dataset to be loaded. Each dataset is specified by a dictionary with the following keys:\nbase_dir::String: relative path to the data with respect to the path given in path_data. If path_data is not specified in the config file, path_data for this dataset is assumed to refer to an absolute path instead.\nexp::String: e.g., \"historical\"\nvariables::Vector{String}: e.g., [\"tos\", \"tas\"]\nstatistics::Vector{String}: may be empty for fixed variables for which no statistics are computed. In that case, statistics is set to [\"none\"] and a warning is thrown unless for known fixed variables (for now just [orog]).\nThe following keys are optional:\nsubdirs: vector of strings; only subdirectories that contain any of the given strings in their name will be considered.\ntimeranges:\naliases:\n\nWhen the data was preprocessed with ESMValTool, the structure of the directories where the data is stored looks as follows. Uppercase names refer to variables, lowercase names mean that the names can be arbitrary unless stated differently in the comments to the right. \n\n├── BASE_DIR # arbitrary (ESMValTool recipe name + _ + YYYYMMDD_HHMMSS)\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)\n│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)\n│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── other output from ESMValTool\n....\n\nBASE_DIR is the name of the recipe plus the date and time using the format YYYYMMDDHHMMSS. ALIAS corresponds to the name (chosen by the user) of the diagnostics defined in the recipe. `VARSTATISTICrefers to the name of the entries among thevariables` section in the ESMValTool recipe. We set these names to the short name of the variable (e.g. 'tas') and the applied statistic (e.g. 'CLIM'),  concatenated by an underscore (e.g, tasCLIM). Any name can be chosen here; but when using VARSTAT, the data can be subset to certain statistics only (see TODO).\n\nIf there is one subdirectory for each climate variable (this is, for instance, the case when one ESMValTool recipe is used for a single variable), the structure of the data is nearly the same. The only difference is that the upper most directory, BASEDIR, has subdirectories which then point to the directory called 'preproc'. The name of the subdirectories (subdir1, subdir2) is the name of the recipe concatenated with the timestamp in the format YYYYMMDDHHMMSS by an underscore. Note that here, we assume one subdirectory per climate variable, and thus the name of each of the subdirectories is assumened to contain VAR, e.g. (BASEDIR/recipetaslgm or BASEDIR/recipetoslgm).\n\n├── BASE_DIR\n│   └── subdir1  # name must contain \"_VAR_\" where VAR is the short_name of the variable, e.g. _tos_\n│   └── subdir2  # name must contain \"_VAR_\" where VAR is the short_name of the variable, e.g. _tos_\n│       └── preproc # this directory must be called 'preproc'\n│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe\n│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe\n│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics\n│       │      │            └── model1.nc\n│       │      │            └── model2.nc\n│       │      │            └── ...\n│       │      │       └── VAR_STATISTIC\n│       │      │            └── ...\n│       └── possibly other output from ESMValTool\n....","category":"section"},{"location":"Manual/loading-data/#Loading-a-single-dataset-into-a-YAXArray","page":"Loading data","title":"Loading a single dataset into a YAXArray","text":"The function that all defineDataMap functions eventually calls is loadPreprocData.  It can be used to directly load data into a YAXArray. It accepts a vector paths to netcdf files and the filename format (and some optional  keyword arguments, like dtype).\n\npaths = [\n    \"path/to/data/dir/CMIP6_AWI-ESM-1-1-LR_Amon_lgm_r1i1p1f1_tas_gn.nc\", \n    \"path/to/data/dir/CMIP6_CESM2-FV2_Amon_lgm_r1i2p2f1_tas_gn.nc\"\n]\nfilename_format = \"MIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE_GRID\"\nv1 = loadPreprocData(paths, filename_format; dtype = \"cmip\")","category":"section"}]
}
