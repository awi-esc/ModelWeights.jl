# Loading data

The basic representation of data is in form of a dictionary that simply maps from ids 
(Strings) to the data itself stored as [YAXArrays](https://juliadatacubes.github.io/YAXArrays.jl/v0.6.1/).
We name this type alias a `DataMap`. 


## Load several datasets into a DataMap

Data is loaded with the function `defineDataMap`. It defines several methods that we explain further below. 

The `defineDataMap` methods provide a set of default keyword arguments: 

- `preview::Bool = false`: set to true if instead of loading the data, a list of paths to 
the data that would be loaded with the given paths and constraints, is returned.

- `sorted::Bool = true`: set to false, if the loaded data should not be sorted alphabetically according to 
the model dimension.


The most important two arguments are `filename_format` and `dtype` which we will explain in turn next:

### Filename format

- `filename_format::Union{Symbol, String}`: This argument is important since the data is loaded based on the information retrieved from the filenames of the data.

There are three predefined filename formats:

- `VARIABLE_TABLEID_MODEL_EXPERIMENT_VARIANT_GRID_TIMERANGE` (:cmip), default value
- `MIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE` (:esmvaltool_cmip5)
- `MIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE_GRID` (:esmvaltool_cmip6)

It is also possible to use the format `:esmvaltool` so that for every file it is automatically
derived based on the fileformat whether it corresponds to CMIP5 or CMIP6.

Further, it is possible to specify your own filename format. TODO

### Data Type (dtype) 

- `dtype::String = "cmip"`

For now, the keyword argument `dtype` is just used to provide specific meta data when `dtype="cmip"`.
This argument should be specified when *not* working with CMIP data, since cmip is the default value.


### Metadata

The metadata of each dataset (the ``.properties`` Dictionary of each YAXArray in a DataMap) 
contains the metadata loaded from the original files as well as additional information if it is provided
in the optional keyword argument `meta_data` of function `defineDataMap` 
(a dictionary with keys of type String).


### Loading data from directories

The datasets loaded in a DataMap all refer to a single variable and experiment, i.e. the 
YAXArrays have the dimensions of the grid the data is defined on, e.g., (`lon`, `lat`) or, 
for 3D data, (`lon`, `lat`, `depth`).

To load data for different datasets, e.g. variable tos for lgm and historical experiment:

````julia
using ModelWeights
paths_datasets = ["path/to/lgm/tos", "path/to/historical/tos"]
ids_datasets = ["lgm-tos", "historical-tos"]
defineDataMap(paths_datasets, ids_datasets; dtype = "cmip")
````

You might have several directories from where you want to load data for a single dataset, e.g. 
when you store CMIP5 and CMIP6 data at different locations. `defineDataMap` also accepts Vectors 
of Vectors, e.g.:

````julia
paths_datasets = [
    ["path/to/cmip5/lgm/tos", "path/to/cmip6/lgm/tos"], 
    ["path/to/cmip5/historical/tos", "path/to/cmip6/historical/tos"]
]
ids_datasets = ["lgm-tos", "historical-tos"]
defineDataMap(paths_datasets, ids_datasets; dtype = "cmip")
````

If you just want to load a single dataset, Vectors aren't needed, e.g.:

````julia
defineDataMap("path/to/lgm/tos", "lgm-tos"; dtype = "cmip")
````


### Loading data preprocessed with ESMValTool 

#### Based on recipes
If you use ESMValTool to preprocess data, you can use the recipes for preprocessing the data 
as config files to load the or some of the data into a ModelWeights.DataMap.
The first argument points to the top-level directory where the data is stored, namely the same
that was used in ESMValTool as base data directory.
The second argument points to a directory that contains one or more recipes, namely the filled out versions of the recipes that are generated by ESMValTool, to be found in the run-directory. These have the same name as the recipe itself concatenated with _filled in the end.

To ensure that the first two arguments are correctly interpreted, the third argument must be set
to `:esmvaltool_recipes`.  
In this case, the default value for `filename_format` is set to :esmvaltool, not :cmip. 

````julia
defineDataMap("path/to/base/data/dir", "path/to/recipes/dir", :esmvaltool_recipes; dtype = "cmip")
````

#### Based on config files

If the data was preprocessed with ESMValTool, it is also possible to specify a config yaml file with 
the required values. Here is an example that loads tas and tos data for the experiments 
lgm, historical and piControl: 

````yaml
base_path_data: "/path/to/dir/with/preprocessed/data"

datasets: [
  {
    base_dir: "LGM", 
    exp: "lgm", 
    variables: ["tas", "tos"],
    aliases: ["lgm"],
    statistics: ["CLIM"], 
    subset: {
      base_subdirs: ["20241114"]
    }
  },
  {
    base_dir: "piControl", 
    exp: "piControl", 
    variables: ["tas", "tos"],
    aliases: ["piControl"],  
    statistics: ["CLIM"],
    subset: {
      base_subdirs: ["lgm_models", "20250322"]
    }
  },
    {
    base_dir: "historical", 
    exp: "historical", 
    variables: ["tas", "tos"],
    aliases: ["historical"], 
    statistics: ["CLIM"]
  }
]
````


TODO: update the following expected keys

Keys expected in the config-yaml file:
- `path_data`: base path to where the preprocessed data is stored. This path will be concatenated with the directories specified for each dataset. It can 
be omitted if inside datasets (see below), `base_dir` refers to the entire absolute path.
- `datasets`: list of each dataset to be loaded. Each dataset is specified by a dictionary with the following keys:
    - `base_dir::String`: relative path to the data with respect to the path given in `path_data`. If `path_data` is not specified in the config file, `path_data` for this dataset is assumed to refer to an absolute path instead.
    - `exp::String`: e.g., "historical"
    - `variables::Vector{String}`: e.g., ["tos", "tas"]
    - `statistics::Vector{String}`: may be empty for fixed variables for which no statistics are computed. In that case, `statistics` is set to ["none"] and a warning is thrown unless for known fixed variables (for now just [`orog`]).

   The following keys are optional:
   - `subdirs`: vector of strings; only subdirectories that contain any of the given strings in their name will be considered.
   - `timeranges`:
   - `aliases`:







When the data was preprocessed with ESMValTool, the structure of the directories where the data is stored looks as follows.
Uppercase names refer to variables, lowercase names mean that the names can be arbitrary unless stated differently in the comments to the right. 

```bash
├── BASE_DIR # arbitrary (ESMValTool recipe name + _ + YYYYMMDD_HHMMSS)
│       └── preproc # this directory must be called 'preproc'
│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)
│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)
│       │      │            └── model1.nc
│       │      │            └── model2.nc
│       │      │            └── ...
│       │      │       └── VAR_STATISTIC
│       │      │            └── ...
│       │      └── ALIAS # arbitrary (name of the diagnostic used in the ESMValTool recipe, chosen by the user)
│       │      │       └── VAR_STATISTIC # name of entry among `variables` in the ESMValTool recipe e.g. tos_CLIM (chosen by the user)
│       │      │            └── model1.nc
│       │      │            └── model2.nc
│       │      │            └── ...
│       │      │       └── VAR_STATISTIC
│       │      │            └── ...
│       └── other output from ESMValTool
....
```

`BASE_DIR` is the name of the recipe plus the date and time using the format YYYYMMDD_HHMMSS.
`ALIAS` corresponds to the name (chosen by the user) of the diagnostics defined in the recipe.
`VAR_STATISTIC` refers to the name of the entries among the `variables` section in the ESMValTool recipe.
We set these names to the short name of the variable (e.g. 'tas') and the applied statistic (e.g. 'CLIM'), 
concatenated by an underscore (e.g, tas_CLIM). Any name can be chosen here; but when using VAR_STAT,
the data can be subset to certain statistics only (see TODO).


If there is one subdirectory for each climate variable (this is, for instance, the case when one ESMValTool recipe is used for a single variable), the structure of the data is nearly the same. The only difference is that the upper most directory, BASE_DIR, has subdirectories which then point to the directory called 'preproc'. The name of the subdirectories (`subdir1`, `subdir2`) is the name of the recipe concatenated with the timestamp in the format YYYYMMDD_HHMMSS by an underscore.
Note that here, we assume one subdirectory per climate variable, and thus the name of each of the subdirectories is assumened to contain _VAR_, e.g. (BASE_DIR/recipe_tas_lgm or BASE_DIR/recipe_tos_lgm).

```bash
├── BASE_DIR
│   └── subdir1  # name must contain "_VAR_" where VAR is the short_name of the variable, e.g. _tos_
│   └── subdir2  # name must contain "_VAR_" where VAR is the short_name of the variable, e.g. _tos_
│       └── preproc # this directory must be called 'preproc'
│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe
│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics
│       │      │            └── model1.nc
│       │      │            └── model2.nc
│       │      │            └── ...
│       │      │       └── VAR_STATISTIC
│       │      │            └── ...
│       │      └── ALIAS # the name of the diagnostic in the ESMValTool recipe
│       │      │       └── VAR_STATISTIC  # can be any name, but this schema useful for subsetting easily wrt statistics
│       │      │            └── model1.nc
│       │      │            └── model2.nc
│       │      │            └── ...
│       │      │       └── VAR_STATISTIC
│       │      │            └── ...
│       └── possibly other output from ESMValTool
....
```


## Loading a single dataset into a YAXArray

The function that all `defineDataMap` functions eventually calls is `loadPreprocData`. 
It can be used to directly load data into a YAXArray.
It accepts a vector paths to netcdf files and the filename format (and some optional 
keyword arguments, like `dtype`).

````julia
paths = [
    "path/to/data/dir/CMIP6_AWI-ESM-1-1-LR_Amon_lgm_r1i1p1f1_tas_gn.nc", 
    "path/to/data/dir/CMIP6_CESM2-FV2_Amon_lgm_r1i2p2f1_tas_gn.nc"
]
filename_format = "MIP_MODEL_TABLEID_EXPERIMENT_VARIANT_VARIABLE_GRID"
v1 = loadPreprocData(paths, filename_format; dtype = "cmip")
````